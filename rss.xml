<?xml version="1.0" encoding="UTF-8" ?>
<rss version="2.0">
<channel>
        <title>CJLD</title>
        <description>CJLD - cjld</description>
        <link>http://cjld.github.io</link>
        <link>http://cjld.github.io</link>
        <lastBuildDate>2015-04-05T19:21:40+08:00</lastBuildDate>
        <pubDate>2015-04-05T19:21:40+08:00</pubDate>
        <ttl>1800</ttl>


        <item>
                <title>Git push 到本地或者远程 repo</title>
                <description>&lt;p&gt;最近有一些需求, 大概就是本地有几个仓库, 需要相互之间 push, pull, 并且希望能够立即同步 到 work directory 下, 于是开始尝试了一发&lt;/p&gt;
&lt;p&gt;创建了一个 git 仓库在 &lt;code&gt;~/p1&lt;/code&gt; 下, 然后&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;    git clone ~/p1 ~/p2&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;成功了! git 可以 clone 本地仓库, 并且在 &lt;code&gt;~/p2&lt;/code&gt; 目录下也有对应的 origin.&lt;/p&gt;
&lt;p&gt;第二个实验就是看看能不能 push 到远程仓库上, ssh 什么都设置好了以后, 在 vps 上通过 &lt;code&gt;git init&lt;/code&gt; 创建了一个空的 git 仓库, 尝试能不能吧本地的repo push 上去, remote 的设置命令为 &lt;code&gt;git remote add origin ssh://root@vps.randonl.me/root/test_git&lt;/code&gt;,&lt;/p&gt;
&lt;p&gt;push 一发尝试了一下, 发现出了问题&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;    remote: error: refusing to update checked out branch: refs/heads/master[K
    remote: error: By default, updating the current branch in a non-bare repository[K
    remote: error: is denied, because it will make the index and work tree inconsistent[K
    remote: error: with what you pushed, and will require &amp;#39;git reset --hard&amp;#39; to match[K
    remote: error: the work tree to HEAD.[K
    remote: error: [K
    remote: error: You can set &amp;#39;receive.denyCurrentBranch&amp;#39; configuration variable to[K
    remote: error: &amp;#39;ignore&amp;#39; or &amp;#39;warn&amp;#39; in the remote repository to allow pushing into[K
    remote: error: its current branch; however, this is not recommended unless you[K
    remote: error: arranged to update its work tree to match what you pushed in some[K
    remote: error: other way.[K
    remote: error: [K
    remote: error: To squelch this message and still keep the default behaviour, set[K
    remote: error: &amp;#39;receive.denyCurrentBranch&amp;#39; configuration variable to &amp;#39;refuse&amp;#39;.[K
    To remote reop&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;查了一下, 似乎是 git 并不允许 push 到远程正在工作的目录, 这个问题有两种解决方法, 一个就是建立仓库的时候使用 &lt;code&gt;--bare&lt;/code&gt;, 这样会导致我们的仓库 没有工作目录, 这不是我们想要的, 于是使用另外一个方案 , 需要修改配置 &lt;code&gt;receive.denyCurrentBranch&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;这个设置有如下参数:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;    receive.denyCurrentBranch
    If set to true or &amp;quot;refuse&amp;quot;, git-receive-pack will deny a ref update to the currently checked out branch of a non-bare repository. Such a push is potentially dangerous because it brings the HEAD out of sync with the index and working tree. If set to &amp;quot;warn&amp;quot;, print a warning of such a push to stderr, but allow the push to proceed. If set to false or &amp;quot;ignore&amp;quot;, allow such pushes with no message. Defaults to &amp;quot;refuse&amp;quot;.&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;我们将它设置为 &lt;code&gt;ignore&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;push 成功了, 但是发现文件并没有更新, 这是因为我们的 work directory 并没有更改, 我们可以通过 reset HEAD 来同步, 但是这样还不够快, 于是乎我们可以使用这个设置的 另一个选项, 也就是 &lt;code&gt;updateInstead&lt;/code&gt;, 通过这个变量就可以直接更新了, 不过很可惜似乎 低版本的 git 不支持这个选项&lt;/p&gt;
&lt;p&gt;为了升级到最新的 git 我们需要用 ppa 源&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;    sudo add-apt-repository ppa:git-core/ppa
    sudo apt-get update
    sudo apt-get upgrade git&lt;/code&gt;&lt;/pre&gt;
</description>
                <link>http://cjld.github.io/2015/03/28/gitpt</link>
                <guid>http://cjld.github.io/2015/03/28/gitpt</guid>
                <pubDate>2015-03-28T00:00:00+08:00</pubDate>
        </item>

        <item>
                <title>Anaconda & Theano 学习</title>
                <description>&lt;p&gt;Anaconda 是一个用于科学计算的 Python 发行版, 带有很多用于科学计算的包, Anaconda 的 python 3.4 的版本和 theano 似乎有 bug, theano 使用了 python 2.7 的 API 导致出错, 所以需要使用 Anaconda 的 python 2.7 版本&lt;/p&gt;
&lt;p&gt;常常写完一个修改一个模块以后会需要重新import改模块, 这里可以使用 &lt;code&gt;reload(module)&lt;/code&gt; 来重新导入该模块&lt;/p&gt;
&lt;p&gt;ipython notebook 在 command 模式带 &lt;code&gt;ctrl&lt;/code&gt; 的快捷键往往不需要加 &lt;code&gt;ctrl&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;Theano 可以使用 CPU 多线程加速, 也可以使用 GPU, CPU 多线程加速如下:&lt;/p&gt;
&lt;p&gt;设置 &lt;code&gt;THEANO_FLAGS&lt;/code&gt; 中的 &lt;code&gt;openmp=True&lt;/code&gt; 设置 &lt;code&gt;OMP_NUM_THREADS&lt;/code&gt; 为线程数量, 如 &lt;code&gt;2&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;Theano 还可以使用 GPU, 甚至多 GPU, 这里在 windows 上更详细的安装方法详见 &lt;a href=&quot;http://deeplearning.net/software/theano/install.html#gpu-windows&quot;&gt;这里&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;这里, 我们的 Theano 库需要用 &lt;code&gt;cl.exe&lt;/code&gt; 和 &lt;code&gt;nvcc.exe&lt;/code&gt; 进行编译, 我们需要将这两个路径加入 环境变量&lt;code&gt;PATH&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;这里执行 &lt;code&gt;import theano.sandbox.cuda&lt;/code&gt; 时出现了一个错误&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;nvcc fatal   : Microsoft Visual Studio configuration file &amp;#39;vcvars64.bat&amp;#39; could not be found for installation at &amp;#39;C:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/bin/../..&amp;#39;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;看上去似乎 CUDA 的 Compiler 好像在寻找 VC 用于配置环境的 bat 文件, 我是用的版本似乎没有, 所以我们创建一个&lt;/p&gt;
</description>
                <link>http://cjld.github.io/2014/12/14/theano</link>
                <guid>http://cjld.github.io/2014/12/14/theano</guid>
                <pubDate>2014-12-14T00:00:00+08:00</pubDate>
        </item>

        <item>
                <title>CMake 学习</title>
                <description>&lt;p&gt;捡起许久以前编写的代码, 是一个Qt project, 并且还有一大堆乱七八糟的依赖, 编译起来简直抓狂, 所以想趁机会学习一下CMake&lt;/p&gt;
&lt;p&gt;之前在学 CMake 和 Scons 之间挣扎了一下, 最终还是觉得 CMake 靠谱一点, CMake 的优势 是可以直接将 CMakeList.txt 编译成其他 IDE 可以识别的工程, 比如 VS 的 sln, makefile, Eclipse, 甚至连 sublime 都有.&lt;/p&gt;
&lt;p&gt;这里主要的参考资料是 &lt;a href=&quot;http://sewm.pku.edu.cn/src/paradise/reference/CMake%20Practice.pdf&quot;&gt;http://sewm.pku.edu.cn/src/paradise/reference/CMake%20Practice.pdf&lt;/a&gt; 和 &lt;a href=&quot;http://zh.wikibooks.org/zh/CMake_%E5%85%A5%E9%96%80&quot;&gt;http://zh.wikibooks.org/zh/CMake_%E5%85%A5%E9%96%80&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;设置-generator&quot;&gt;设置 generator&lt;/h2&gt;
&lt;p&gt;在 windows 下默认使用的是生成 vs 的 solution, 如果要改为 makefile 文件有两种办法:&lt;/p&gt;
&lt;p&gt;修改 cmake 运行参数&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;cmake -G &amp;quot;MinGW Makefiles&amp;quot; .&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;或者在&lt;code&gt;Cmakelist.txt&lt;/code&gt;里面这么写&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;set(cmake_generator &amp;quot;MinGW Makefiles&amp;quot;)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;生成的 makefile 可以使用 &lt;code&gt;make help&lt;/code&gt; 查看可用的 make 指令, 以及使用 &lt;code&gt;make VERBOSE=1&lt;/code&gt; 查看详细的生成命令, 另外可以用 &lt;code&gt;cmake --help-command xxx&lt;/code&gt; 来查看对应命令的帮助,&lt;/p&gt;
&lt;p&gt;使用 set 可以设置变量, 变量有 5 种类型 FILEPATH PATH STRING BOOL INTERNAL, 并且可以设置 cache 属性, 多用来提供用户接口&lt;/p&gt;
&lt;h2 id=&quot;使用外部编译&quot;&gt;使用外部编译&lt;/h2&gt;
&lt;p&gt;所谓使用外部编译, 就是把编译程序和源代码分离开来, 放置在不同的文件夹下, 好处很多, 比如利于版本控制, 利于打包程序, 利于清理程序&lt;/p&gt;
&lt;p&gt;方法很简单, 切换到想要的目录下执行 cmake 即可&lt;/p&gt;
&lt;h2 id=&quot;设置编译存放目录&quot;&gt;设置编译存放目录&lt;/h2&gt;
&lt;p&gt;这两句话分别设置了二进制文件的存放位置&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;SET(EXECUTABLE_OUTPUT_PATH ${PROJECT_BINARY_DIR}/bin)
SET(LIBRARY_OUTPUT_PATH ${PROJECT_BINARY_DIR}/lib)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;分别对应了&lt;code&gt;ADD_EXECUTABLE&lt;/code&gt; 和 &lt;code&gt;ADD_LIBRARY&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;一些有用的 cmake 变量 &lt;a href=&quot;http://www.cmake.org/Wiki/CMake_Useful_Variables&quot;&gt;http://www.cmake.org/Wiki/CMake_Useful_Variables&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;设置安装目录&quot;&gt;设置安装目录&lt;/h2&gt;
&lt;p&gt;默认的 make 里面是没有 install 选项的, 需要在 cmakelist.txt 里通过添加 install 指令实现. 在这之前需要设置 &lt;code&gt;CMAKE_INSTALL_PREFIX&lt;/code&gt;, install 指令的简单 使用&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;install(TARGETS hello RUNTIME DESTINATION bin)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;以及 install 可以不是 &lt;code&gt;TARGETS&lt;/code&gt;, 还可以是 &lt;code&gt;files&lt;/code&gt;, &lt;code&gt;PROGRAMS&lt;/code&gt;, &lt;code&gt;DIRECTORY&lt;/code&gt;, 甚至支持正则表达式&lt;/p&gt;
&lt;h2 id=&quot;使用库&quot;&gt;使用库&lt;/h2&gt;
&lt;p&gt;主要是&lt;code&gt;include_directories&lt;/code&gt;, &lt;code&gt;link_directories&lt;/code&gt;, &lt;code&gt;target_link_libraries&lt;/code&gt;, 要记住这几个指令最好放在 &lt;code&gt;add_executable&lt;/code&gt; 之后, 因为实验过程中发现先后是会产生 不同的现象的, &lt;code&gt;add_definitions&lt;/code&gt; 添加宏指令, 以及 &lt;code&gt;target_link_libraries&lt;/code&gt; 可以 为 release 和 debug 分别指定库&lt;/p&gt;
&lt;p&gt;以及 vs 如果需要设置为 64 位的话得用&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;cmake .. -G &amp;quot;Visual Studio 12 2013 Win64&amp;quot;&lt;/code&gt;&lt;/pre&gt;
</description>
                <link>http://cjld.github.io/2014/11/05/cmakelearn</link>
                <guid>http://cjld.github.io/2014/11/05/cmakelearn</guid>
                <pubDate>2014-11-05T00:00:00+08:00</pubDate>
        </item>

        <item>
                <title>Blender 源码学习 --- Notifiers</title>
                <description>&lt;p&gt;via &lt;a href=&quot;http://wiki.blender.org/index.php/Dev:2.5/Source/Architecture/Notifiers/Updates&quot;&gt;http://wiki.blender.org/index.php/Dev:2.5/Source/Architecture/Notifiers/Updates&lt;/a&gt; and &lt;a href=&quot;http://wiki.blender.org/index.php/Dev:2.5/Source/Architecture/Notifiers/Data&quot;&gt;http://wiki.blender.org/index.php/Dev:2.5/Source/Architecture/Notifiers/Data&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;blender 里有三种更新的方式:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Notifier: Notifier 主要用来通知窗口系统&lt;/li&gt;
&lt;li&gt;Dependency Graph: 主要针对依赖数据的改变&lt;/li&gt;
&lt;li&gt;Redraw Tag: 重绘事件, 经常被 Notifier 调用&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;个人感觉这几个的层级关系是 Dependency Graph -&amp;gt; Notifier -&amp;gt; Redraw Tag&lt;/p&gt;
&lt;h2 id=&quot;notifier&quot;&gt;Notifier&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;void WM_event_add_notifier(const struct bContext *C, unsigned int type, void *data);&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;向窗口系统发出 notifier, type 有四个层次: * category: 前缀为 &lt;code&gt;NC_&lt;/code&gt;, 如 window, screen, object * Data: 前缀为 &lt;code&gt;ND_&lt;/code&gt;, 根据 category 不同, data 不同, 如 object 下有 &lt;code&gt;ND_TRANSFORM&lt;/code&gt;, &lt;code&gt;ND_POSE&lt;/code&gt; * Data sub types, Action, 多数情况下不常用, 可以参考 &lt;code&gt;WM_types.h&lt;/code&gt;&lt;/p&gt;
&lt;h2 id=&quot;约定&quot;&gt;约定&lt;/h2&gt;
&lt;p&gt;这里有几条简单的方针:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Datablocks: 当修改对应的 datablock 时, 应当修改对应的 category, 然后再找到正确的 &lt;code&gt;ND_*&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Space/ Region Data: 可以使用 &lt;code&gt;NC_SPACE&lt;/code&gt;, 然后找到对应的 &lt;code&gt;ND_*&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;User Perferences: 发送 &lt;code&gt;NC_WINDOW&lt;/code&gt; Notifier 来刷新整个屏幕&lt;/li&gt;
&lt;/ul&gt;
</description>
                <link>http://cjld.github.io/2014/08/16/blendccodenotifier</link>
                <guid>http://cjld.github.io/2014/08/16/blendccodenotifier</guid>
                <pubDate>2014-08-16T00:00:00+08:00</pubDate>
        </item>

        <item>
                <title>Blender 源码学习 --- Modifier</title>
                <description>&lt;p&gt;reference: * &lt;a href=&quot;http://wiki.blender.org/index.php/User:Enjalot/Creating_a_custom_modifier&quot;&gt;http://wiki.blender.org/index.php/User:Enjalot/Creating_a_custom_modifier&lt;/a&gt; * &lt;a href=&quot;http://wiki.blender.org/index.php/User:Apinzonf/Dev:Doc/Tutorial_Modifier&quot;&gt;http://wiki.blender.org/index.php/User:Apinzonf/Dev:Doc/Tutorial_Modifier&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Blender Modifier 的结构有点小复杂, 需要修改的部分有点多 需要修改的部分:&lt;/p&gt;
&lt;ol type=&quot;1&quot;&gt;
&lt;li&gt;&lt;code&gt;properties_data_modifier.py&lt;/code&gt;: Modifier 的 UI 界面, 接口是 SCALING&lt;/li&gt;
&lt;li&gt;&lt;code&gt;DNA_modifier_types.h&lt;/code&gt;: 这里有两个东西需要修改
&lt;ol type=&quot;a&quot;&gt;
&lt;li&gt;在这里添加 &lt;code&gt;ModifierType&lt;/code&gt; 枚举类&lt;/li&gt;
&lt;li&gt;声明和 UI 交互的数据结构&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;RNA_access.h&lt;/code&gt;: 添加 StructRNA 的声明, 而定义是自动生成的&lt;/li&gt;
&lt;li&gt;&lt;code&gt;rna_modifier.c&lt;/code&gt;: 这里有三处需要修改
&lt;ol type=&quot;a&quot;&gt;
&lt;li&gt;这里添加的是 &lt;strong&gt;添加Modifier下拉列表UI&lt;/strong&gt; 的值, 同时指向 1 和 2.a&lt;/li&gt;
&lt;li&gt;修改&lt;code&gt;rna_Modifier_refine&lt;/code&gt;, 这里相当于定义了从 2.a 到 3 的链接&lt;/li&gt;
&lt;li&gt;在 &lt;code&gt;RNA_def_modifier&lt;/code&gt; 中创建 &lt;code&gt;StructRNA&lt;/code&gt;, 然后由系统自动生成定义, 和 3 链接&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;li&gt;创建 Modifier 所需的文件 &lt;code&gt;MOD_xxx.c&lt;/code&gt;, 这个文件包含所有算法, 以及事件处理, 修改 cmakelists 加入编译列表&lt;/li&gt;
&lt;li&gt;在 &lt;code&gt;MOD_modifiertypes.h&lt;/code&gt; 中声明 modifier 所需要的类型, 将会在 5 中定义&lt;/li&gt;
&lt;li&gt;在 &lt;code&gt;MOD_util.c&lt;/code&gt; 创建 &lt;code&gt;INIT_TYPE&lt;/code&gt;, 相当于从 2.a 到 6 的链接&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;这是一个简易的关系图:&lt;/p&gt;
&lt;figure&gt;
&lt;img src=&quot;../../../../img/blender/blender_modifier_relation.png&quot; /&gt;
&lt;/figure&gt;
&lt;p&gt;具体代码解析:&lt;/p&gt;
&lt;ol type=&quot;1&quot;&gt;
&lt;li&gt;&lt;p&gt;首先是编写 UI, 我们在 &lt;code&gt;properties_data_modifier.py&lt;/code&gt; 添加这么行代码:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;class DATA_PT_modifiers(ModifierButtonsPanel, Panel): 
...
def SCALING(self, layout, ob, md):
    layout.prop(md, &amp;quot;scaleui&amp;quot;)
...&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;SCALING&lt;/code&gt; 这个函数是有意义的, 在第 4.a 步会出现, 同时这里的 &lt;code&gt;md&lt;/code&gt; 就是我们在第 4.c 步创建的 &lt;code&gt;RNA_ScalingModifier&lt;/code&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;DNA_modifier_types.h&lt;/code&gt;: 修改两处
&lt;ol type=&quot;a&quot;&gt;
&lt;li&gt;&lt;p&gt;在 ModifierType 枚举类中创建 &lt;code&gt;eModifierType_Scaling&lt;/code&gt;, 这是 blender 最顶层能够访问到的元素&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;typedef enum ModifierType {
    eModifierType_None = 0,
    ...
    ...
    eModifierType_Wireframe         = 48,
    eModifierType_Scaling           = 49, // 这里的编号是需要连续
    NUM_MODIFIER_TYPES
} ModifierType;&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;创建 &lt;code&gt;struct ScalingModifierData&lt;/code&gt;, 这个 struct 会在两处用到, 一个是生成 &lt;code&gt;RNA_ScalingModifier&lt;/code&gt;, 第二个是在 &lt;code&gt;MOD_scaling.c&lt;/code&gt; 中用到&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;typedef struct ScalingModifierData {
    ModifierData modifier;
    float scale;
    int pad; // blender 为了保证兼容性的 8 byte 对齐
} ScalingModifierData;&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;RNA_access.h&lt;/code&gt;: 声明 &lt;code&gt;RNA_ScalingModifier&lt;/code&gt;, 实际定义由在 4.c 步骤生成&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;extern StructRNA RNA_ScalingModifier;&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;rna_modifier.c&lt;/code&gt;, 修改三处&lt;/p&gt;
&lt;ol type=&quot;a&quot;&gt;
&lt;li&gt;&lt;p&gt;在这里可以喊道各种被分类好了的 Modifier, 找到对应的位置插入以下代码:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;EnumPropertyItem modifier_type_items[] = {
    ...
    {0, &amp;quot;&amp;quot;, 0, N_(&amp;quot;Deform&amp;quot;), &amp;quot;&amp;quot;},
    ...
    {eModifierType_Scaling, &amp;quot;SCALING&amp;quot;, ICON_MAN_SCALE, &amp;quot;Scaling the mesh&amp;quot;, &amp;quot;&amp;quot;},
    ...
};&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这一步同时让系统知道 &lt;code&gt;eModifierType_Scaling&lt;/code&gt; 对应了 python 中的哪个函数来绘制 UI&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;在函数体 &lt;code&gt;rna_Modifier_refine&lt;/code&gt; 中添加对应代码:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;static StructRNA *rna_Modifier_refine(struct PointerRNA *ptr)
{
    ...
    switch (md-&amp;gt;type) {
        ...
        case eModifierType_Scaling:
            return &amp;amp;RNA_ScalingModifier;
    ...
}&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这里让系统得知 &lt;code&gt;eModifierType_Scaling&lt;/code&gt; 对应的 RNA&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;定义 RNA&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;static void rna_def_modifier_scaling(BlenderRNA *brna)
{
    StructRNA *srna;
    PropertyRNA *prop;

    srna = RNA_def_struct(brna, &amp;quot;ScalingModifier&amp;quot;, &amp;quot;Modifier&amp;quot;);
    RNA_def_struct_ui_text(srna, &amp;quot;Scaling Modifier&amp;quot;, &amp;quot;Scaling effect modifier&amp;quot;);
    RNA_def_struct_sdna(srna, &amp;quot;ScalingModifierData&amp;quot;);
    RNA_def_struct_ui_icon(srna, ICON_MAN_SCALE);

    /* scaleui: name for &amp;quot;properties_data_modifier.py&amp;quot;*/
    prop = RNA_def_property(srna, &amp;quot;scaleui&amp;quot;, PROP_FLOAT, PROP_NONE); 

    /*scale: name for &amp;quot;DNA_modifier_types.h&amp;quot;*/
    RNA_def_property_float_sdna(prop, NULL, &amp;quot;scale&amp;quot;);

    RNA_def_property_range(prop, -FLT_MAX, FLT_MAX);
    RNA_def_property_ui_range(prop, -100, 100, 1, 3);
    RNA_def_property_ui_text(prop, &amp;quot;Scale&amp;quot;, &amp;quot;Scale factor&amp;quot;);
    RNA_def_property_update(prop, 0, &amp;quot;rna_Modifier_update&amp;quot;);

}

......

void RNA_def_modifier(BlenderRNA *brna)
{
    ...
    rna_def_modifier_remesh(brna);
    rna_def_modifier_skin(brna);
    rna_def_modifier_scaling(brna);
}&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;创建对应文件, 修改对应文件夹下的 cmakelists&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;set(SRC
    ...
    intern/MOD_scaling.c
    ...
)&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;MOD_modifiertypes.h&lt;/code&gt;: 添加 &lt;code&gt;ModifierTypeInfo&lt;/code&gt; 的声明&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;extern ModifierTypeInfo modifierType_Scaling;&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;MOD_util.c&lt;/code&gt;: 让 blender 能够通过 &lt;code&gt;eModifierType_Scaling&lt;/code&gt; 获取 &lt;code&gt;ModifierTypeInfo&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#define INIT_TYPE(typeName) (types[eModifierType_##typeName] = &amp;amp;modifierType_##typeName)
...
    INIT_TYPE(Scaling);
#undef INIT_TYPE&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;MOD_util.c&lt;/code&gt; 核心代码部分, 关于 &lt;code&gt;ModifierTypeInfo&lt;/code&gt; 的定义可以在 &lt;code&gt;BKE_modifier.h&lt;/code&gt; 中看到非常详细的定义&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;/*
 * ***** BEGIN GPL LICENSE BLOCK *****
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software  Foundation,
 * Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
 *
 * The Original Code is Copyright (C) 2005 by the Blender Foundation.
 * All rights reserved.
 *
 * Contributor(s): Your name
 *
 * ***** END GPL LICENSE BLOCK *****
 *
 */

/** \file blender/modifiers/intern/MOD_scaling.c
 *  \ingroup modifiers
 */


#include &amp;quot;DNA_meshdata_types.h&amp;quot;

#include &amp;quot;BLI_math.h&amp;quot;
#include &amp;quot;BLI_utildefines.h&amp;quot;
#include &amp;quot;BLI_string.h&amp;quot;

#include &amp;quot;MEM_guardedalloc.h&amp;quot;

#include &amp;quot;BKE_cdderivedmesh.h&amp;quot;
#include &amp;quot;BKE_particle.h&amp;quot;
#include &amp;quot;BKE_deform.h&amp;quot;

#include &amp;quot;MOD_modifiertypes.h&amp;quot;
#include &amp;quot;MOD_util.h&amp;quot;


static void initData(ModifierData *md)
{
    ScalingModifierData *smd = (ScalingModifierData *) md;
    smd-&amp;gt;scale = 1.0f;
}

static void copyData(ModifierData *md, ModifierData *target)
{
    ScalingModifierData *smd = (ScalingModifierData *) md;
    ScalingModifierData *tsmd = (ScalingModifierData *) target;
    tsmd-&amp;gt;scale = smd-&amp;gt;scale;
}

static int isDisabled(ModifierData *md, int UNUSED(useRenderParams))
{
    ScalingModifierData *smd = (ScalingModifierData *) md;
    /* disable if modifier is 1.0 for scale*/
    if (smd-&amp;gt;scale == 1.0f) return 1;
    return 0;
}

static CustomDataMask requiredDataMask(Object *UNUSED(ob), ModifierData *md)
{
    ScalingModifierData *smd = (ScalingModifierData *)md;
    CustomDataMask dataMask = 0;
    return dataMask;
}

static void ScalingModifier_do(
        ScalingModifierData *smd, Object *ob, DerivedMesh *dm,
        float (*vertexCos)[3], int numVerts)
{
    int i;
    float scale;
    scale = smd-&amp;gt;scale;

    for (i = 0; i &amp;lt; numVerts; i++) {
        vertexCos[i][0] = vertexCos[i][0] * scale;
        vertexCos[i][1] = vertexCos[i][1] * scale;
        vertexCos[i][2] = vertexCos[i][2] * scale;
    }
}

static void deformVerts(ModifierData *md, Object *ob, DerivedMesh *derivedData,
                        float (*vertexCos)[3], int numVerts, ModifierApplyFlag UNUSED(flag))
{
    DerivedMesh *dm = get_dm(ob, NULL, derivedData, NULL, 0);

    ScalingModifier_do((ScalingModifierData *)md, ob, dm,
                      vertexCos, numVerts);

    if (dm != derivedData)
        dm-&amp;gt;release(dm);
}

static void deformVertsEM(
        ModifierData *md, Object *ob, struct BMEditMesh *editData,
        DerivedMesh *derivedData, float (*vertexCos)[3], int numVerts)
{
    DerivedMesh *dm = get_dm(ob, editData, derivedData, NULL, 0);

    ScalingModifier_do((ScalingModifierData *)md, ob, dm,
                      vertexCos, numVerts);

    if (dm != derivedData)
        dm-&amp;gt;release(dm);
}


ModifierTypeInfo modifierType_Scaling = {
    /* name */              &amp;quot;Scaling&amp;quot;,
    /* structName */        &amp;quot;ScalingModifierData&amp;quot;,
    /* structSize */        sizeof(ScalingModifierData),
    /* type */              eModifierTypeType_OnlyDeform,
    /* flags */             eModifierTypeFlag_AcceptsMesh |
                            eModifierTypeFlag_SupportsEditmode,

    /* copyData */          copyData,
    /* deformVerts */       deformVerts,
    /* deformMatrices */    NULL,
    /* deformVertsEM */     deformVertsEM,
    /* deformMatricesEM */  NULL,
    /* applyModifier */     NULL,
    /* applyModifierEM */   NULL,
    /* initData */          initData,
    /* requiredDataMask */  requiredDataMask,
    /* freeData */          NULL,
    /* isDisabled */        isDisabled,
    /* updateDepgraph */    NULL,
    /* dependsOnTime */     NULL,
    /* dependsOnNormals */  NULL,
    /* foreachObjectLink */ NULL,
    /* foreachIDLink */     NULL,
    /* foreachTexLink */    NULL,
};&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;a href=&quot;../../../../assets/bmdl.diff&quot;&gt;patch 文件&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;乱&quot;&gt;乱&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;RNA_access.h&lt;/code&gt;: 各种 StructRNA 声明的地方&lt;/li&gt;
&lt;li&gt;&lt;code&gt;BKE_modifier.h&lt;/code&gt;: 关于 &lt;code&gt;ModifierTypeInfo&lt;/code&gt; 的定义&lt;/li&gt;
&lt;/ul&gt;
</description>
                <link>http://cjld.github.io/2014/08/16/blendccodemodifier</link>
                <guid>http://cjld.github.io/2014/08/16/blendccodemodifier</guid>
                <pubDate>2014-08-16T00:00:00+08:00</pubDate>
        </item>

        <item>
                <title>Blender 源码学习 --- Operator</title>
                <description>&lt;p&gt;via &lt;a href=&quot;http://wiki.blender.org/index.php/Dev:2.5/Source/Architecture/Operators/Tutorial&quot;&gt;http://wiki.blender.org/index.php/Dev:2.5/Source/Architecture/Operators/Tutorial&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Blender 的 c 语言 api 与 python api 颇为相似&lt;/p&gt;
&lt;h2 id=&quot;mesh-subdivide&quot;&gt;Mesh Subdivide&lt;/h2&gt;
&lt;p&gt;下面是对 blender 中的 mesh subdivide operator 代码的分析&lt;/p&gt;
&lt;h3 id=&quot;registration&quot;&gt;Registration&lt;/h3&gt;
&lt;p&gt;首先我们需要在 window manager 中注册 operator, 编写的注册函数将会在启动时调用.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;void MESH_OT_subdivide(wmOperatorType *ot)
{
    /* identifiers */
    ot-&amp;gt;name= &amp;quot;Subdivide&amp;quot;;
    ot-&amp;gt;description= &amp;quot;Split selected faces into smaller faces.&amp;quot;;
    ot-&amp;gt;idname= &amp;quot;MESH_OT_subdivide&amp;quot;;
 
    /* api callbacks */
    ot-&amp;gt;exec= subdivide_exec;
    ot-&amp;gt;poll= ED_operator_editmesh;
 
    /* flags */
    ot-&amp;gt;flag= OPTYPE_REGISTER|OPTYPE_UNDO;
 
    /* properties */
    RNA_def_int(ot-&amp;gt;srna, &amp;quot;number_cuts&amp;quot;, 1, 1, 10, &amp;quot;Number of Cuts&amp;quot;, &amp;quot;&amp;quot;, 1, INT_MAX);
}&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;第一行&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;void MESH_OT_subdivide(wmOperatorType *ot)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;其中 &lt;code&gt;OT&lt;/code&gt; 是指 operator type.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;    /* identifiers */
    ot-&amp;gt;name= &amp;quot;Subdivide&amp;quot;;
    ot-&amp;gt;description= &amp;quot;Split selected faces into smaller faces.&amp;quot;;
    ot-&amp;gt;idname= &amp;quot;MESH_OT_subdivide&amp;quot;;&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;ot-&amp;gt;name&lt;/code&gt; 相当于 &lt;code&gt;bl_label&lt;/code&gt;, 用于显示ui&lt;/li&gt;
&lt;li&gt;&lt;code&gt;ot-&amp;gt;description&lt;/code&gt; 相当于 &lt;code&gt;bl_description&lt;/code&gt;, tooltip&lt;/li&gt;
&lt;li&gt;&lt;code&gt;ot-&amp;gt;idname&lt;/code&gt; 相当于 &lt;code&gt;bl_idname&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;MESH_OT_subdivide&lt;/code&gt; 相当于 &lt;code&gt;mesh.subdivide&lt;/code&gt;, 必须唯一&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;/* api callbacks */
ot-&amp;gt;exec= subdivide_exec;
ot-&amp;gt;poll= ED_operator_editmesh;
ot-&amp;gt;flag= OPTYPE_REGISTER|OPTYPE_UNDO;&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;相当于python api 中的 exec 和 poll, &lt;code&gt;ot-&amp;gt;flag&lt;/code&gt; 相当于 &lt;code&gt;bl_options&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;    prop = RNA_def_int(ot-&amp;gt;srna, &amp;quot;number_cuts&amp;quot;, 1, 1, INT_MAX, &amp;quot;Number of Cuts&amp;quot;, &amp;quot;&amp;quot;, 1, 10);

    PropertyRNA *RNA_def_int(StructOrFunctionRNA *cont_, const char *identifier, int default_value,
                     int hardmin, int hardmax, const char *ui_name, const char *ui_description,
                     int softmin, int softmax)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这里可以看一下 &lt;code&gt;RNA_def_int&lt;/code&gt; 的定义, &lt;code&gt;identifier&lt;/code&gt;, 相当于变量名, 用来访问该变量, 其他都挺直观的, 不过不太清楚 &lt;code&gt;hardmax&lt;/code&gt; 和 &lt;code&gt;softmax&lt;/code&gt; 有什么区别, 不过一般 hard 更大&lt;/p&gt;
&lt;h3 id=&quot;wm&quot;&gt;WM&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;void ED_operatortypes_mesh(void)
{
    ...
    WM_operatortype_append(MESH_OT_subdivide);
    ...
}&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;注册该 operator, 在这里可以看到所有注册的关于mesh的operator&lt;/p&gt;
&lt;h3 id=&quot;poll&quot;&gt;Poll&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;int ED_operator_editmesh(bContext *C)
{
    Object *obedit= CTX_data_edit_object(C);
    if(obedit &amp;amp;&amp;amp; obedit-&amp;gt;type==OB_MESH)
        return NULL != ((Mesh *)obedit-&amp;gt;data)-&amp;gt;edit_mesh;
    CTX_wm_operator_poll_msg_set(C, &amp;quot;selected object isn&amp;#39;t a mesh or not in editmode&amp;quot;);
    return 0;
}&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;该函数返回是否可以运行, 首先通过 &lt;code&gt;bContext&lt;/code&gt; 获得 object, 然后判断是否是 mesh, 是否有mesh, 以及通过 &lt;code&gt;CTX_wm_operator_poll_msg_set&lt;/code&gt; 告知信息&lt;/p&gt;
&lt;h3 id=&quot;exec&quot;&gt;Exec&lt;/h3&gt;
&lt;p&gt;运行函数, 用于没有用户交互时使用, 和 transform operator 正好相反&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;static int subdivide_exec(bContext *C, wmOperator *op)
{
    Scene *scene = CTX_data_scene(C);
    Object *obedit= CTX_data_edit_object(C);
    EditMesh *em= BKE_mesh_get_editmesh((Mesh *)obedit-&amp;gt;data);
    int cuts= RNA_int_get(op-&amp;gt;ptr,&amp;quot;number_cuts&amp;quot;);
 
    esubdivideflag(obedit, em, cuts);
 
    DAG_object_flush_update(scene, obedit, OB_RECALC_DATA);
    WM_event_add_notifier(C, NC_OBJECT|ND_GEOM_SELECT, obedit);
 
    return OPERATOR_FINISHED;
}&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;首先是函数声明&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;static int subdivide_exec(bContext *C, wmOperator *op)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;两个参数, 一个是 context, 和 python 中的 context 类似, 第二个是 &lt;code&gt;wmOperator&lt;/code&gt;, 注意这个和注册时的 &lt;code&gt;wmOperatorType&lt;/code&gt; 不一样, 返回值用于返回 Operator 是否运行成功&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;int cuts = RNA_int_get(op-&amp;gt;ptr, &amp;quot;number_cuts&amp;quot;);&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;op-&amp;gt;ptr&lt;/code&gt; 用于获得 RNA, &lt;code&gt;RNA_int_get&lt;/code&gt; 用于获取 int properties, &lt;code&gt;number_cuts&lt;/code&gt; 为之前声明的变量id&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;DAG_object_flush_update(scene, obedit, OB_RECALC_DATA);
WM_event_add_notifier(C, NC_OBJECT|ND_GEOM_DATA, obedit);
// EDBM_update_generic(em, true, true); in new blender code&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在完成操作以后, 我们需要通知对此数据有依赖的操作, &lt;code&gt;DAG_id_tag_update&lt;/code&gt; 用于通知 dependency graph, &lt;code&gt;WM_main_add_notifier&lt;/code&gt; 用于通知窗口系统&lt;/p&gt;
&lt;h2 id=&quot;d-view-zoom&quot;&gt;3D View Zoom&lt;/h2&gt;
&lt;h3 id=&quot;registration-1&quot;&gt;Registration&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;void VIEW3D_OT_zoom(wmOperatorType *ot)
{
    /* identifiers */
    ot-&amp;gt;name = &amp;quot;Zoom View&amp;quot;;
    ot-&amp;gt;description = &amp;quot;Zoom in/out in the view&amp;quot;;
    ot-&amp;gt;idname = &amp;quot;VIEW3D_OT_zoom&amp;quot;;

    /* api callbacks */
    ot-&amp;gt;invoke = viewzoom_invoke;
    ot-&amp;gt;exec = viewzoom_exec;
    ot-&amp;gt;modal = viewzoom_modal;
    ot-&amp;gt;poll = ED_operator_region_view3d_active;
    ot-&amp;gt;cancel = viewzoom_cancel;

    /* flags */
    ot-&amp;gt;flag = OPTYPE_BLOCKING | OPTYPE_GRAB_POINTER;
    // OPTYPE_BLOCKING 表示获得所有鼠标事件, 包括在窗口外部

    RNA_def_int(ot-&amp;gt;srna, &amp;quot;delta&amp;quot;, 0, INT_MIN, INT_MAX, &amp;quot;Delta&amp;quot;, &amp;quot;&amp;quot;, INT_MIN, INT_MAX);
    RNA_def_int(ot-&amp;gt;srna, &amp;quot;mx&amp;quot;, 0, 0, INT_MAX, &amp;quot;Zoom Position X&amp;quot;, &amp;quot;&amp;quot;, 0, INT_MAX);
    RNA_def_int(ot-&amp;gt;srna, &amp;quot;my&amp;quot;, 0, 0, INT_MAX, &amp;quot;Zoom Position Y&amp;quot;, &amp;quot;&amp;quot;, 0, INT_MAX);
}&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&quot;poll-1&quot;&gt;Poll&lt;/h3&gt;
&lt;p&gt;现在的代码和 2.5 有点出入, 以现在的为准&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// context.c
RegionView3D *CTX_wm_region_view3d(const bContext *C)
{
    ScrArea *sa = CTX_wm_area(C);
    // 相当于 context.area
    ARegion *ar = CTX_wm_region(C);
    // 相当于 context.region
    // region 是 area 的 subcontext

    if (sa &amp;amp;&amp;amp; sa-&amp;gt;spacetype == SPACE_VIEW3D)
    // context.area.space.type == &amp;#39;VIEW_3D&amp;#39;
        if (ar)
            return ar-&amp;gt;regiondata;
            // context.region_data
    return NULL;
}

int ED_operator_region_view3d_active(bContext *C)
{
    if (CTX_wm_region_view3d(C))
        return true;

    CTX_wm_operator_poll_msg_set(C, &amp;quot;expected a view3d region&amp;quot;);
    return false;
}&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&quot;invoke&quot;&gt;Invoke&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;static int viewzoom_invoke(bContext *C, wmOperator *op, wmEvent *event)
// 和 exec 不同的是, 多了一个 event, 可以用来获得鼠标事件
{
    if(RNA_property_is_set(op-&amp;gt;ptr, &amp;quot;delta&amp;quot;)) {
        return viewzoom_exec(C, op);
    }
    // 如果已经定义了 delta property, 直接运行
    else {
        /* makes op-&amp;gt;customdata */
        viewops_data(C, op, event);
        // 初始化信息, 存入 op-&amp;gt;customdata, 这是一个 void* 指针, 可以用于存临时信息
 
        /* add temp handler */
        WM_event_add_modal_handler(C, &amp;amp;CTX_wm_window(C)-&amp;gt;   handlers, op);
        // WM_event_add_modal_handler(C, op); in blender 2.72
        // 添加一个 modal hander, 和 python 中的 context.window_manager.modal_handler_add(self) 一样, 这个语句同时会拦截其他 event handler
 
        return OPERATOR_RUNNING_MODAL;
        // 表明现在开始运行modal
    }
}&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&quot;modal&quot;&gt;Modal&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;static int viewzoom_modal(bContext *C, wmOperator *op, wmEvent *event)
{
    ViewOpsData *vod= op-&amp;gt;customdata;
 
    /* execute the events */
    switch(event-&amp;gt;type) {
        case MOUSEMOVE:
            viewzoom_apply(vod, event-&amp;gt;x, event-&amp;gt;y);
            break;
        // 将鼠标移动应用给 viewzoom
 
        default:
            /* origkey may be zero when invoked from a button   */
            if(ELEM3(event-&amp;gt;type, ESCKEY, LEFTMOUSE, RIGHTMOUSE) || (event-&amp;gt;type==vod-&amp;gt;origkey &amp;amp;&amp;amp; event-&amp;gt;val==0)) {
                request_depth_update(CTX_wm_region_view3d(C));
 
                MEM_freeN(vod);
                op-&amp;gt;customdata= NULL;
 
                return OPERATOR_FINISHED;
            }
    }
 
    return OPERATOR_RUNNING_MODAL;
}&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&quot;简易实现-translate&quot;&gt;简易实现 translate&lt;/h2&gt;
&lt;p&gt;这里仿照&lt;a href=&quot;http://wiki.blender.org/index.php/Dev:2.5/Py/Scripts/Cookbook/Code_snippets/Interface#A_modal_operator&quot;&gt;这个 Python 脚本&lt;/a&gt;实现一个C版本, 作为练习, 因为新的 api 和 wiki 有些出入&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;/* my transform begin */
#include &amp;quot;BKE_object.h&amp;quot;
#include &amp;quot;BKE_depsgraph.h&amp;quot;

static int mytransform_exec(bContext *C, wmOperator *op)
{
    float value[2];
    PropertyRNA *prop = RNA_struct_find_property(op-&amp;gt;ptr, &amp;quot;value&amp;quot;);
    RNA_property_float_get_array(op-&amp;gt;ptr, prop, value);
    // 从 property 获得变量

    Object *obj = CTX_data_active_object(C);
    obj-&amp;gt;loc[0] = value[0];
    obj-&amp;gt;loc[1] = value[1];
    // 设置 object location

    DAG_id_tag_update(&amp;amp;obj-&amp;gt;id, OB_RECALC_OB);
    WM_event_add_notifier(C, NC_OBJECT | ND_TRANSFORM, obj);
    // 更新 dependency, 添加 notifier

    return OPERATOR_FINISHED;
}

static int mytransform_modal(bContext *C, wmOperator *op, const wmEvent *event)
{
    if (event-&amp;gt;type == LEFTMOUSE)
        return OPERATOR_FINISHED;

    if (event-&amp;gt;type == RIGHTMOUSE)
        return OPERATOR_CANCELLED;

    if (event-&amp;gt;type != MOUSEMOVE)
        printf(&amp;quot;Uncatched event type %d\n&amp;quot;, (int)(event-&amp;gt;type));

    PropertyRNA *prop = RNA_struct_find_property(op-&amp;gt;ptr, &amp;quot;value&amp;quot;);
    float value[2] = { event-&amp;gt;x / 100.0f, event-&amp;gt;y / 100.0f };

    RNA_property_float_set_array(op-&amp;gt;ptr, prop, value);
    // 获得鼠标事件, 设置 property

    mytransform_exec(C, op);

    return OPERATOR_RUNNING_MODAL;
}

static int mytransform_poll(bContext *C)
{
    Object *obj = CTX_data_active_object(C);
    if (obj == NULL) {
        CTX_wm_operator_poll_msg_set(C, &amp;quot;No Active Object in context.&amp;quot;);
        return false;
    }
    // 判断 active object 是否存在
    else return true;
}

static int mytransform_invoke(bContext *C, wmOperator *op, const wmEvent *event)
{
    PropertyRNA *prop = RNA_struct_find_property(op-&amp;gt;ptr, &amp;quot;value&amp;quot;);

    if (RNA_property_is_set(op-&amp;gt;ptr, prop))
        return mytransform_exec(C, op);

    WM_event_add_modal_handler(C, op);
    // 添加 modal handler

    return OPERATOR_RUNNING_MODAL;
}

static void TRANSFORM_OT_mytransform(struct wmOperatorType *ot) 
{
    /* identifiers */
    ot-&amp;gt;name = &amp;quot;MyTransform&amp;quot;;
    ot-&amp;gt;description = &amp;quot;Move object in XY plane by mouse move&amp;quot;;
    ot-&amp;gt;idname = &amp;quot;TRANSFORM_OT_my_transform&amp;quot;;
    ot-&amp;gt;flag = OPTYPE_REGISTER | OPTYPE_UNDO | OPTYPE_BLOCKING;

    /* api callbacks */
    ot-&amp;gt;invoke = mytransform_invoke;
    ot-&amp;gt;exec = mytransform_exec;
    ot-&amp;gt;poll = mytransform_poll;
    ot-&amp;gt;modal = mytransform_modal;

    RNA_def_float_vector(
        ot-&amp;gt;srna, &amp;quot;value&amp;quot;, 2, NULL, -FLT_MAX, FLT_MAX,
        &amp;quot;Value&amp;quot;, &amp;quot;Vector that add to object&amp;quot;, -FLT_MAX, FLT_MAX);
}

/* my transform end */

void transform_operatortypes(void)
{
    .......
    WM_operatortype_append(TRANSFORM_OT_mytransform);
    // 注册 operator
}&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&quot;乱&quot;&gt;乱&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;BKE_context.h&lt;/code&gt;, 很多操作 context 的函数&lt;/li&gt;
&lt;li&gt;&lt;code&gt;RNA_access.h&lt;/code&gt;, RNA 数据操作函数&lt;/li&gt;
&lt;li&gt;&lt;code&gt;RNA_struct_find_property&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;event-&amp;gt;type == EVT_MODAL_MAP&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;BKE_object.h&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
                <link>http://cjld.github.io/2014/08/16/blendccode</link>
                <guid>http://cjld.github.io/2014/08/16/blendccode</guid>
                <pubDate>2014-08-16T00:00:00+08:00</pubDate>
        </item>

        <item>
                <title>Blender Interface</title>
                <description>&lt;p&gt;via &lt;a href=&quot;http://wiki.blender.org/index.php/Dev:2.5/Py/Scripts/Cookbook/Code_snippets/Interface#A_modal_operator&quot;&gt;http://wiki.blender.org/index.php/Dev:2.5/Py/Scripts/Cookbook/Code_snippets/Interface#A_modal_operator&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;blender 主要有两种 UI:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;继承自 &lt;code&gt;bpy.types.Panel&lt;/code&gt;, 有 properties 和 draw function&lt;/li&gt;
&lt;li&gt;&lt;code&gt;bpy.types.Operator&lt;/code&gt;, 有 properties, execute function, 可选的 invoke function&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;一个注册文件中所有类的方法是 &lt;code&gt;bpy.utils.register_module(__name__)&lt;/code&gt;&lt;/p&gt;
&lt;h2 id=&quot;panels-and-buttons&quot;&gt;Panels and buttons&lt;/h2&gt;
&lt;p&gt;可以通过以下代码添加一个按钮&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;self.layout.operator(&amp;quot;hello.hello&amp;quot;, text=&amp;#39;Hej&amp;#39;).country = &amp;quot;Sweden&amp;quot;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;UILayout.operator&lt;/code&gt; 具有额外参数:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;text&lt;/code&gt;: 按钮上的字&lt;/li&gt;
&lt;li&gt;&lt;code&gt;text_ctxt&lt;/code&gt;: 用于翻译&lt;/li&gt;
&lt;li&gt;&lt;code&gt;translate&lt;/code&gt;: 是否翻译&lt;/li&gt;
&lt;li&gt;&lt;code&gt;icon&lt;/code&gt;: 图标, 比如 ‘QUESTION’, ‘ERROR’, ‘CANCEL’&lt;/li&gt;
&lt;li&gt;&lt;code&gt;emboss&lt;/code&gt;: bool, 是否显示按钮的凸起&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;同时这个函数具有返回值, 可以对对应的 operator 设置调用时的 properties, 可以设置多个 properties, 如下:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;op = row.operator(&amp;quot;transform.translate&amp;quot;)
op.value = (1,-1,-1)
op.proportional_size = 1&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;和 operator 一样, panel 同样有 &lt;code&gt;bl_*&lt;/code&gt; 的前缀, 常用的有&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;bl_idname&lt;/code&gt;: id&lt;/li&gt;
&lt;li&gt;&lt;code&gt;bl_label&lt;/code&gt;: label, 提示性文字, 标题&lt;/li&gt;
&lt;li&gt;&lt;code&gt;bl_space_type&lt;/code&gt;: 属于哪个 space, 如 &lt;code&gt;VIEW_3D&lt;/code&gt;, &lt;code&gt;PROPERTIES&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;bl_region_type&lt;/code&gt;: 属于哪个 region, 如 &lt;code&gt;TOOLS&lt;/code&gt;, &lt;code&gt;TOOL_PROPS&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;bl_context&lt;/code&gt;: 取决于具体环境, 这三项从上到下决定了具体 panel 的具体位置&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;可重载函数:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;classmethod poll(context)&lt;/code&gt;: 返回bool, 是否绘制ui&lt;/li&gt;
&lt;li&gt;&lt;code&gt;draw_header(context)&lt;/code&gt;: 用来绘制标题&lt;/li&gt;
&lt;li&gt;&lt;code&gt;draw(context)&lt;/code&gt;: 用来绘制 panel&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;panel-properties&quot;&gt;Panel properties&lt;/h2&gt;
&lt;p&gt;除了 operator, 还可以使用 panel 控制 properties, 如下:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;layout.prop(ob, &amp;#39;myRnaInt&amp;#39;)         # RNA properties
layout.prop(ob, &amp;#39;[&amp;quot;myRnaInt&amp;quot;]&amp;#39;)     # ID properties&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;以及一些常用的 ui 元素:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;layout.template_ID&lt;/code&gt;: ID 链接&lt;/li&gt;
&lt;li&gt;&lt;code&gt;prop_menu_enum&lt;/code&gt;: 枚举类菜单&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;panel-layout&quot;&gt;Panel layout&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;layout.row()&lt;/code&gt;: 在同一行, 有一个参数, align, 表示元素是否为紧凑排列&lt;/li&gt;
&lt;li&gt;&lt;code&gt;layout.column()&lt;/code&gt;: 同 row, 按列排列&lt;/li&gt;
&lt;li&gt;&lt;code&gt;layout.alignment&lt;/code&gt;: 设置对齐方式&lt;/li&gt;
&lt;li&gt;&lt;code&gt;layout.box()&lt;/code&gt;: 包围盒&lt;/li&gt;
&lt;li&gt;&lt;code&gt;layout.separator()&lt;/code&gt;: 分隔符&lt;/li&gt;
&lt;li&gt;&lt;code&gt;layout.split()&lt;/code&gt;: 有一个参数 percentage, 按行宽度百分比拆分&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;menu&quot;&gt;menu&lt;/h2&gt;
&lt;p&gt;找到对应的菜单, 使用 &lt;code&gt;prepend&lt;/code&gt;/&lt;code&gt;append&lt;/code&gt; 函数添加绘制函数&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;bpy.types.INFO_MT_mesh_add.prepend(menu_func)
bpy.types.INFO_MT_mesh_add.append(menu_func)

bpy.types.INFO_MT_mesh_add.remove(menu_func)&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&quot;a-modal-operator&quot;&gt;A modal operator&lt;/h2&gt;
&lt;p&gt;modal operator 和普通的 operator 的区别是, &lt;code&gt;Operator.modal&lt;/code&gt; 被重载用来处理事件, 主要用于交互式的 operator&lt;/p&gt;
&lt;p&gt;modal 函数的返回值有 4 种:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;FINISHED&lt;/code&gt;: 结束&lt;/li&gt;
&lt;li&gt;&lt;code&gt;CANCELLED&lt;/code&gt;: 取消&lt;/li&gt;
&lt;li&gt;&lt;code&gt;RUNNING_MODAL&lt;/code&gt;: 等待下一个事件触发继续运行&lt;/li&gt;
&lt;li&gt;&lt;code&gt;PASS_THROUGH&lt;/code&gt;: 不知道…把 blender 整个代码搜了一遍也只有很少很集中的地方用到了, 应该不用也没问题, 感觉像是多个 modal operator 调用时处理的事情?&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;可以通过重载 &lt;code&gt;__init__&lt;/code&gt; 和 &lt;code&gt;__del__&lt;/code&gt; 获得 modal operator 开始和结束的信息&lt;/p&gt;
&lt;p&gt;在调用时使用语句 &lt;code&gt;context.window_manager.modal_handler_add(self)&lt;/code&gt;&lt;/p&gt;
</description>
                <link>http://cjld.github.io/2014/08/12/blendui</link>
                <guid>http://cjld.github.io/2014/08/12/blendui</guid>
                <pubDate>2014-08-12T00:00:00+08:00</pubDate>
        </item>

        <item>
                <title>Blender Addon</title>
                <description>&lt;p&gt;via &lt;a href=&quot;http://www.blender.org/documentation/blender_python_api_2_70a_release/info_tutorial_addon.html&quot;&gt;http://www.blender.org/documentation/blender_python_api_2_70a_release/info_tutorial_addon.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;bl_info，包含字段仅用于在user preference显示用&lt;/p&gt;
&lt;p&gt;&lt;code&gt;register&lt;/code&gt; 与 &lt;code&gt;unregister&lt;/code&gt; 将会被调用，当在user preference里对addon激活和关闭时&lt;/p&gt;
&lt;h2 id=&quot;bpy.types.operator-继承&quot;&gt;bpy.types.Operator 继承&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;bl_idname&lt;/code&gt;: 必须，切唯一，用于api调用&lt;/li&gt;
&lt;li&gt;&lt;code&gt;bl_label&lt;/code&gt;: 必须，表示操作名称&lt;/li&gt;
&lt;li&gt;&lt;code&gt;__doc__&lt;/code&gt;: 用于显示为tooltip&lt;/li&gt;
&lt;li&gt;&lt;code&gt;bl_options&lt;/code&gt;: 枚举类集合
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;REGISTER&lt;/code&gt; 默认选项&lt;/li&gt;
&lt;li&gt;&lt;code&gt;UNDO&lt;/code&gt; 支持撤销&lt;/li&gt;
&lt;li&gt;&lt;code&gt;BLOCKING&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;MACRO&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;GRAB_POINTER&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;PRESET&lt;/code&gt; 在操作设置显示一个 preset 按钮&lt;/li&gt;
&lt;li&gt;&lt;code&gt;INTERNAL&lt;/code&gt; 无法从外部搜索到&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;execute(context)&lt;/code&gt;: 运行 op，同时返回状态&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;operator-property&quot;&gt;Operator Property&lt;/h2&gt;
&lt;p&gt;通过在类内部声明 property，可以让operator拥有参数输入，并且在最后一次操作面板里会出现一个简单地面板，显示所有 property&lt;/p&gt;
&lt;h2 id=&quot;添加菜单&quot;&gt;添加菜单&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;bpy.types.VIEW3D_MT_object.append(menu_func)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;类似于重载 menu 类中的 draw 函数，&lt;code&gt;append&lt;/code&gt; 为在draw之前运行，&lt;code&gt;prepend&lt;/code&gt; 在之后运行，以及 &lt;code&gt;remove&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;def menu_func(self, context):
    self.layout.operator(ObjectCursorArray.bl_idname)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;通过 layout.operator 绘制一个操纵 operator 的菜单项&lt;/p&gt;
</description>
                <link>http://cjld.github.io/2014/08/02/buildaraddon</link>
                <guid>http://cjld.github.io/2014/08/02/buildaraddon</guid>
                <pubDate>2014-08-02T00:00:00+08:00</pubDate>
        </item>

        <item>
                <title>Blender Architecture</title>
                <description>&lt;p&gt;继续挖坑….&lt;/p&gt;
</description>
                <link>http://cjld.github.io/2014/07/29/buildarchitecture</link>
                <guid>http://cjld.github.io/2014/07/29/buildarchitecture</guid>
                <pubDate>2014-07-29T00:00:00+08:00</pubDate>
        </item>

        <item>
                <title>编译 Blender</title>
                <description>&lt;p&gt;今天编译Blender也算是小折腾了一把，作为一个虽然用着 windows 但是一直使用 linux 工具链的非主流，碰到问题还搜不着…&lt;/p&gt;
&lt;p&gt;主要碰到三个问题：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;svn 无法 checkout，似乎是天朝网络的原因，挂上代理就好了&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;运行 &lt;code&gt;msgfmt.exe&lt;/code&gt; 提示 &lt;code&gt;libgcc_s_sjlj-1.dll&lt;/code&gt; 缺失&lt;/p&gt;
&lt;p&gt;再三确定 &lt;code&gt;libgcc_s_sjlj-1.dll&lt;/code&gt; 已经加入环境变量，但似乎不管用，看官方 &lt;a href=&quot;http://wiki.blender.org/index.php/Dev:Doc/Building_Blender/Windows/MinGW/CMake&quot;&gt;wiki&lt;/a&gt;，发现和问题 &lt;code&gt;MinGW &amp;amp; Redistribution&lt;/code&gt; 颇为类似，将若干 dll 拷贝到 &lt;code&gt;cmake_build\bin&lt;/code&gt; 以后问题解决&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;最后链接 &lt;code&gt;Blender.exe&lt;/code&gt; 时出现链接错误 &lt;code&gt;i386 architecture of input file &#39;winblender.rc.obj&#39; is incompatible with i386:x86-64 output.&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;这个问题折腾了半天，本本里确实有几个版本的 mingw，但在 make 前为了防止环境变量污染还特地把 path 清空了，百思不得其解，去翻阅 makefile 时发现不知何时调用了另外一个 mingw 里的 &lt;code&gt;windres.exe&lt;/code&gt;，把环境变量清空以后重新执行 cmake 后问题解决…&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;配置 qtcreator 到没出什么bug，照着 &lt;a href=&quot;http://wiki.blender.org/index.php/Dev:Doc/IDE_Configuration/Linux_CMake_QtCreator&quot;&gt;wiki&lt;/a&gt; 来就可以了&lt;/p&gt;
</description>
                <link>http://cjld.github.io/2014/07/28/buildblender</link>
                <guid>http://cjld.github.io/2014/07/28/buildblender</guid>
                <pubDate>2014-07-28T00:00:00+08:00</pubDate>
        </item>

        <item>
                <title>Python, C/C++, SWIG</title>
                <description>&lt;p&gt;让 Python 和 C++ 相互调用，方法主要有以下几种：&lt;/p&gt;
&lt;h2 id=&quot;通过-extern-生成动态链接库&quot;&gt;通过 extern 生成动态链接库&lt;/h2&gt;
&lt;p&gt;via &lt;a href=&quot;http://www.oschina.net/question/234345_48628&quot;&gt;http://www.oschina.net/question/234345_48628&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;最经典的方法，通过在头文件里加入 &lt;code&gt;extern &amp;quot;C&amp;quot;&lt;/code&gt; 来定义动态链接符号，通过 &lt;code&gt;ctypes.CDLL&lt;/code&gt; 来连接，优点是即插即用，缺点是只能以纯C的方式调用，而且只能传输基础类型。&lt;/p&gt;
&lt;h2 id=&quot;使用-python-api&quot;&gt;使用 Python API&lt;/h2&gt;
&lt;p&gt;via &lt;a href=&quot;https://docs.python.org/2/extending/extending.html&quot;&gt;https://docs.python.org/2/extending/extending.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;最科学的方法，通过 python 提供的 API 来编写，编译出的文件可以直接 import，非常干净，而且不光可以 python 调用 c++，同样可以用 c++ 调用 python&lt;/p&gt;
&lt;h2 id=&quot;swig&quot;&gt;SWIG&lt;/h2&gt;
&lt;p&gt;发现 SWIG 以后真是相见恨晚，SWIG 几乎可以把 C++ 包装给所有语言用，而且不需要在原来基础上增加或者修改代码。&lt;/p&gt;
&lt;p&gt;基本上按着&lt;a href=&quot;http://www.swig.org/Doc1.3/Python.html&quot;&gt;官方教程&lt;/a&gt;来一遍就知道怎么回事了，有一点一直被坑了很久，那就是编译出来的 &lt;code&gt;.dll&lt;/code&gt;得把后缀改成 &lt;code&gt;.pyd&lt;/code&gt; 才行，python3 import 的时候是不会找 &lt;code&gt;.dll&lt;/code&gt; 后缀的…&lt;/p&gt;
</description>
                <link>http://cjld.github.io/2014/07/24/swigtest</link>
                <guid>http://cjld.github.io/2014/07/24/swigtest</guid>
                <pubDate>2014-07-24T00:00:00+08:00</pubDate>
        </item>

        <item>
                <title>Blender Python API Overview</title>
                <description>&lt;p&gt;via &lt;a href=&quot;http://www.blender.org/documentation/blender_python_api_2_70a_release/info_overview.html&quot;&gt;http://www.blender.org/documentation/blender_python_api_2_70a_release/info_overview.html&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;可以用-python-api-集成的类型&quot;&gt;可以用 python api 集成的类型&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;bpy.types.Panel&lt;/li&gt;
&lt;li&gt;bpy.types.Menu&lt;/li&gt;
&lt;li&gt;bpy.types.Operator&lt;/li&gt;
&lt;li&gt;bpy.types.PropertyGroup&lt;/li&gt;
&lt;li&gt;bpy.types.KeyingSet&lt;/li&gt;
&lt;li&gt;bpy.types.RenderEngine&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;可见，使用 Blender Python API 可以做的事情是在 UI 界面可以做的所有事情，以及集成以上6种类型， 所以python api并不能做所有事情，比如 &lt;a href=&quot;http://wiki.blender.org/index.php/User:Enjalot/Creating_a_custom_modifier&quot;&gt;创建一个modifier&lt;/a&gt;、 &lt;a href=&quot;http://wiki.blender.org/index.php/User:Nazg-gul/WritingNewNode&quot;&gt;创建一个compositing node&lt;/a&gt;， 如有这种需求的时候就需要用到 C/C++ 对源码进行改写了&lt;/p&gt;
&lt;p&gt;感觉blender对python api的理解是简化操作而不是增加特性而实现的。&lt;/p&gt;
&lt;p&gt;在使用以上类型的时候尽量不涉及任何固有变量，固有变量应该被储存在 blender data 里，这样就能被保存和加载了（话说撤销机制是不是也是这么实现的？）， 这么看来其实blender的设计模式并不完全是OOP形式，更像是DOP，面向数据，以及MVC&lt;/p&gt;
&lt;p&gt;从blender源码上来分析也是这种感觉，blender靠一个奇怪的 DNA/RNA 机制实现了动态类型&lt;/p&gt;
&lt;h2 id=&quot;registration&quot;&gt;Registration&lt;/h2&gt;
&lt;h3 id=&quot;module-registration&quot;&gt;Module Registration&lt;/h3&gt;
&lt;p&gt;当一个 python 代码被放在 &lt;code&gt;scripts/addons/&lt;/code&gt; 下时，便会自动的被blender import 并调用 &lt;code&gt;register()&lt;/code&gt; 和 &lt;code&gt;unregister()&lt;/code&gt;&lt;/p&gt;
&lt;h3 id=&quot;class-registration&quot;&gt;Class Registration&lt;/h3&gt;
&lt;p&gt;前面提到的6种类型，在继承以后可以通过 &lt;code&gt;bpy.utils.register_class(cls)&lt;/code&gt; 来注册，或者通过 &lt;code&gt;bpy.utils.register_module(mod)&lt;/code&gt; 来自动注册所有在mod内部的类，按照定义顺序&lt;/p&gt;
&lt;h3 id=&quot;inter-classes-dependencies&quot;&gt;Inter Classes Dependencies&lt;/h3&gt;
&lt;p&gt;注册的时候需要考虑调用顺序&lt;/p&gt;
&lt;h2 id=&quot;manipulating-classes&quot;&gt;Manipulating Classes&lt;/h2&gt;
&lt;p&gt;properties 可以在运行时被动态的添加&lt;/p&gt;
&lt;h2 id=&quot;dynamic-defined-classes&quot;&gt;Dynamic Defined-Classes&lt;/h2&gt;
&lt;p&gt;动态定义类， 这用法太风骚了…还是少用为好&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id=&quot;application-modules&quot;&gt;Application Modules&lt;/h2&gt;
&lt;h3 id=&quot;context-access&quot;&gt;Context Access&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;bpy.context&lt;/code&gt;: blender 上下文信息，所有变量只读，不过可以通过data api修改&lt;/p&gt;
&lt;h3 id=&quot;data-access&quot;&gt;Data Access&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;bpy.data&lt;/code&gt;: blender内部的所有数据（除开context）&lt;/p&gt;
&lt;h3 id=&quot;opetators&quot;&gt;Opetators&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;bpy.ops&lt;/code&gt;: 所有用python，c和宏实现的 operator 都可以被找到&lt;/p&gt;
&lt;p&gt;因为 operator 有一些特性，所以也有一些特殊的调用方法&lt;/p&gt;
&lt;p&gt;所有 operator 支持三个特殊的 positional arguments，因为其他参数都是 keyword arguments，所以不会冲突：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;override_context&lt;/code&gt;: dict type&lt;br /&gt; 用于重载传给 operator 里的 context&lt;/li&gt;
&lt;li&gt;&lt;code&gt;execution_context&lt;/code&gt;: string(enum)&lt;br /&gt; 没看懂有啥用…似乎相关invoke和execute的区别，这个之后的文章再深究&lt;/li&gt;
&lt;li&gt;&lt;code&gt;undo&lt;/code&gt;: bool 是否支持撤销，也就是要不要在做这个操作之前做一次备份&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;比较神奇的是这三个参数顺序是无所谓的，可以查看代码：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;File &amp;quot;Blender Foundation\Blender\2.71\scripts\modules\bpy\ops.py&amp;quot;, line 185, in __call__
    C_dict, C_exec, C_undo = BPyOpsSubModOp._parse_args(args)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;因为三个参数类型不同，所以顺序不同也是可以判断出来的&lt;/p&gt;
&lt;h3 id=&quot;types&quot;&gt;Types&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;bpy.types&lt;/code&gt;: blender 中出现的所有类型&lt;/p&gt;
&lt;p&gt;继承或者添加自定义属性时会用到&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;bpy_struct&lt;/code&gt;: 所有类的基类，可以用来添加key，driver&lt;/li&gt;
&lt;li&gt;&lt;code&gt;ID&lt;/code&gt;: 负责GC，连接和储存的基类&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;utilities&quot;&gt;Utilities&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;bpy.utils&lt;/code&gt;: 各种零碎的实用的函数如 &lt;code&gt;register_class&lt;/code&gt;&lt;/p&gt;
&lt;h3 id=&quot;property-definitions&quot;&gt;Property Definitions&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;bpy.props&lt;/code&gt;: 提供若干属性的声明，有 bool, float, int, string… 以及 update, get/set 的设置&lt;/p&gt;
&lt;p&gt;这种 property 定义方法被称之为 &lt;code&gt;RNA properties&lt;/code&gt;, 除此之外还有一种定义方法是 &lt;code&gt;ID properties&lt;/code&gt;, &lt;code&gt;RNA properties&lt;/code&gt; 的定义是针对一个类型， 而 &lt;code&gt;ID properties&lt;/code&gt; 是针对单个实例的&lt;/p&gt;
&lt;h2 id=&quot;乱&quot;&gt;乱&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;bpy.context.window_manager.popup_menu(draw, title=&amp;quot;Greeting&amp;quot;, icon=&#39;INFO&#39;)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;bpy.ops.object.select_by_type(type=&#39;MESH&#39;)&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
                <link>http://cjld.github.io/2014/07/15/blendscript</link>
                <guid>http://cjld.github.io/2014/07/15/blendscript</guid>
                <pubDate>2014-07-15T00:00:00+08:00</pubDate>
        </item>

        <item>
                <title>Blender Animation</title>
                <description>&lt;p&gt;挖个坑….&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Ctrl&lt;/code&gt; + &lt;code&gt;Alt&lt;/code&gt; + &lt;code&gt;P&lt;/code&gt; : make proxy&lt;/li&gt;
&lt;/ul&gt;
</description>
                <link>http://cjld.github.io/2014/07/03/blendanime</link>
                <guid>http://cjld.github.io/2014/07/03/blendanime</guid>
                <pubDate>2014-07-03T00:00:00+08:00</pubDate>
        </item>

        <item>
                <title>Blender Motion Track</title>
                <description>&lt;p&gt;&lt;a href=&quot;https://www.youtube.com/watch?v=Df3TAZ-VNso&amp;amp;list=PLtuvwW4VAp5tu2RdbRHThM6FVFfvFur1g&amp;amp;index=4&quot;&gt;Blender Motion Track&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;motion-track&quot;&gt;Motion Track&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;Ctrl&lt;/code&gt; + &lt;code&gt;LMB&lt;/code&gt; : add marker and slide&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;two point track&lt;/p&gt;
&lt;figure&gt;
&lt;img src=&quot;../../../../img/blender/noob/m1.gif&quot; /&gt;
&lt;/figure&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;two-point-stabilization&quot;&gt;Two Point Stabilization&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;L&lt;/code&gt; : Display lock to selection&lt;/li&gt;
&lt;li&gt;2D stabilization and 2D stabilization node&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;four-point-track&quot;&gt;four point track&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;img src=&quot;../../../../img/blender/noob/m2.gif&quot; title=&quot;fig:&quot; /&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;solve-camera&quot;&gt;solve camera&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Ctrl&lt;/code&gt; + &lt;code&gt;Shift&lt;/code&gt; : link node&lt;/li&gt;
&lt;li&gt;Nikon D90 lens distortion k1 about -0.15, k2 about 0.1&lt;/li&gt;
&lt;li&gt;&lt;img src=&quot;../../../../img/blender/noob/m3.gif&quot; title=&quot;fig:&quot; /&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;色彩的知识&quot;&gt;色彩的知识&lt;/h2&gt;
&lt;p&gt;常常和 motion track 分不开的就是后期合成， 而颜色合成是后期合成的重要组成部分，对颜色不是很了解，搜了一下发现大有门道，下面是一些关于颜色混合模式的学习资料：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://helpx.adobe.com/cn/photoshop/using/blending-modes.html&quot;&gt;Adobe 里关于色彩混合的帮助&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://stackoverflow.com/questions/5919663/how-does-photoshop-blend-two-images-together&quot;&gt;代码实现&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www.zhihu.com/question/20293077&quot;&gt;知乎上的回答&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;gif 质量好低啊…&lt;/p&gt;
&lt;p&gt;Blender Add-on: BLAM - the static camera calibration toolkit&lt;/p&gt;
&lt;p&gt;motion track 先玩到这，再去玩玩 animation 和 modeling&lt;/p&gt;
</description>
                <link>http://cjld.github.io/2014/06/28/blendmt</link>
                <guid>http://cjld.github.io/2014/06/28/blendmt</guid>
                <pubDate>2014-06-28T00:00:00+08:00</pubDate>
        </item>

        <item>
                <title>Blender Inside Out</title>
                <description>&lt;p&gt;&lt;a href=&quot;https://www.youtube.com/watch?v=YibZKnVc0Zk&amp;amp;list=PLtuvwW4VAp5sn3kYEM8f2WQwPVXIbHXMq&quot;&gt;Blender Inside Out&lt;/a&gt; 对 blender 做了非常系统的介绍，信息量比较大，做些笔记：&lt;/p&gt;
&lt;h2 id=&quot;interface&quot;&gt;Interface&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;N&lt;/code&gt; : Property panel&lt;/li&gt;
&lt;li&gt;&lt;code&gt;T&lt;/code&gt; : Tools panel&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;selection-tools&quot;&gt;Selection Tools&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;RMB&lt;/code&gt; : select one&lt;/li&gt;
&lt;li&gt;&lt;code&gt;A&lt;/code&gt; : (De)select All / Invert&lt;/li&gt;
&lt;li&gt;&lt;code&gt;B&lt;/code&gt; : Border Select&lt;/li&gt;
&lt;li&gt;&lt;code&gt;C&lt;/code&gt; : Circle Select , &lt;code&gt;SW&lt;/code&gt; to change the size&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Ctrl&lt;/code&gt; + &lt;code&gt;LMB&lt;/code&gt; : Polygon Select&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Shift&lt;/code&gt; + &lt;code&gt;...&lt;/code&gt; : Deselect&lt;/li&gt;
&lt;li&gt;&lt;code&gt;MMB&lt;/code&gt; : Deselect&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;transform-tools&quot;&gt;Transform Tools&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;G&lt;/code&gt; : Translate&lt;/li&gt;
&lt;li&gt;&lt;code&gt;R&lt;/code&gt; : Rotate&lt;/li&gt;
&lt;li&gt;&lt;code&gt;S&lt;/code&gt; : Scale&lt;/li&gt;
&lt;li&gt;Pivot center for rotate and scale&lt;/li&gt;
&lt;li&gt;Transform orientation : Global , Local , Normal , Gimbal? , Custom&lt;/li&gt;
&lt;li&gt;&lt;code&gt;X&lt;/code&gt; &lt;code&gt;Y&lt;/code&gt; &lt;code&gt;Z&lt;/code&gt; &lt;code&gt;Shift&lt;/code&gt; Constraint Axis&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Alt&lt;/code&gt; + &lt;code&gt;Space&lt;/code&gt; : Select Orientation&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Shift&lt;/code&gt; + D : Duplicate&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;using-the-search-box-to-find-amost-anything&quot;&gt;Using The Search Box To Find Amost Anything&lt;/h2&gt;
&lt;h2 id=&quot;customizing-the-interface-layout&quot;&gt;Customizing The Interface Layout&lt;/h2&gt;
&lt;p&gt;Right click in split line to split or merge&lt;/p&gt;
&lt;h2 id=&quot;using-the-3d-cursor&quot;&gt;Using The 3D Cursor&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;D&lt;/code&gt; + &lt;code&gt;LMB&lt;/code&gt; | &lt;code&gt;RMB&lt;/code&gt; | &lt;code&gt;Ctrl&lt;/code&gt;: draw | erase | line&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Shift&lt;/code&gt; + &lt;code&gt;S&lt;/code&gt; : snap menu&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;object-mode-versus-edit-mode&quot;&gt;Object Mode Versus Edit Mode&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Tab&lt;/code&gt; : switch between two mode&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Ctrl&lt;/code&gt; + &lt;code&gt;Tab&lt;/code&gt; : (in Edit Mode) switch select mode {v,e,f}&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;mesh-selection-tools&quot;&gt;Mesh Selection Tools&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;L&lt;/code&gt; : select link&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Shift&lt;/code&gt; + &lt;code&gt;R&lt;/code&gt; : Repeat last command&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Ctrl&lt;/code&gt; + &lt;code&gt;N+&lt;/code&gt; | &lt;code&gt;N-&lt;/code&gt; : select more | less around cur select&lt;/li&gt;
&lt;li&gt;&lt;code&gt;P&lt;/code&gt; : separated to another obj&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Y&lt;/code&gt; : split&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Alt&lt;/code&gt; + &lt;code&gt;RMB&lt;/code&gt; : select edge loop like — — —&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Ctrl&lt;/code&gt; + &lt;code&gt;Alt&lt;/code&gt; + &lt;code&gt;RMB&lt;/code&gt; : select edge ring like | | |&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Ctrl&lt;/code&gt; + &lt;code&gt;RMB&lt;/code&gt; : select path&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;object-mesh-snapping&quot;&gt;Object / Mesh Snapping&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;snap to : volume , face, edge, vertex&lt;/li&gt;
&lt;li&gt;snap element : center, active, median, closest&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Ctrl&lt;/code&gt; + &lt;code&gt;LMB&lt;/code&gt; : duplicate and extrude at 3d cursor&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Ctrl&lt;/code&gt; when transform, enable snap&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;edit-model&quot;&gt;Edit model&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;E&lt;/code&gt; : Extrude and Extrude individual&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Ctrl&lt;/code&gt; + &lt;code&gt;V&lt;/code&gt;|&lt;code&gt;F&lt;/code&gt;|&lt;code&gt;E&lt;/code&gt; : vertex/face/edge menu&lt;/li&gt;
&lt;li&gt;&lt;code&gt;I&lt;/code&gt; : face inset&lt;/li&gt;
&lt;li&gt;face edge bevel&lt;/li&gt;
&lt;li&gt;bridge and spin&lt;/li&gt;
&lt;li&gt;loop cuts&lt;/li&gt;
&lt;li&gt;knife&lt;/li&gt;
&lt;li&gt;merge and collapse&lt;/li&gt;
&lt;li&gt;Mesh Creases for subsdiv&lt;/li&gt;
&lt;li&gt;mesh display in property to display normal, length, etc.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;modifiers&quot;&gt;Modifiers&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Ctrl&lt;/code&gt; + &lt;code&gt;H&lt;/code&gt; : hook menu&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.youtube.com/watch?v=ljMePAmmxx4&quot;&gt;all modifiers Tutorial&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;smoothing-groups&quot;&gt;Smoothing Groups&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Mark sharp used by Edge Split modifier&lt;/li&gt;
&lt;li&gt;Crease used by subsurf modifier&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;setting-seams-and-unwrapping&quot;&gt;Setting Seams And Unwrapping&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Mark Seams in Edge menu&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Ctrl&lt;/code&gt; + &lt;code&gt;P&lt;/code&gt; : Pack island&lt;/li&gt;
&lt;li&gt;&lt;code&gt;W&lt;/code&gt; : Weld / Align Menu&lt;/li&gt;
&lt;li&gt;&lt;code&gt;P&lt;/code&gt; : Pin, need to enable live unwarp&lt;/li&gt;
&lt;li&gt;Sculpting UV&lt;/li&gt;
&lt;li&gt;&lt;code&gt;M&lt;/code&gt; move to layer&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;还有好多东西啊… 不想看了， 先玩 motion track 去 …&lt;/p&gt;
</description>
                <link>http://cjld.github.io/2014/06/20/blenderio</link>
                <guid>http://cjld.github.io/2014/06/20/blenderio</guid>
                <pubDate>2014-06-20T00:00:00+08:00</pubDate>
        </item>

        <item>
                <title>Blender 大法好</title>
                <description>&lt;p&gt;美双上课时交过 3dsMax， 无奈不太习惯，越用越蹩脚，最近几天开始尝试 Blender，不禁越用越喜欢~，感觉比当时 Unity3D 的上手速度更快。&lt;/p&gt;
&lt;p&gt;小白 3dsMax 也是浅尝辄止，不太清楚，但是用过 Blender 以后感觉 Blender 更有生命力：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;速度快，在我小本上直接秒开，哪像大 AutoDesk， 启动Logo都要让我看半分钟，而且界面响应速度也不咋地。&lt;/li&gt;
&lt;li&gt;所有操作都可以用 python 实现，每在 UI 界面作一次操作， console 就会输出 python 命令，都免去查 向 Unity 那样查 API 了。&lt;/li&gt;
&lt;li&gt;界面干净，功能正交&lt;/li&gt;
&lt;li&gt;开源的 ~&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这两天看了一下油管上的 &lt;a href=&quot;https://www.youtube.com/watch?v=GTq9sLQOiVs&amp;amp;list=PLzmyR17f55-LVbgnzhS4Xl9zJ3dSCdYW3&quot;&gt;blender beginning tutorial&lt;/a&gt;， 学习了简单的建模和渲染，流体引擎超好玩有木有~&lt;/p&gt;
&lt;p&gt;来个 hot key &lt;img src=&quot;http://wiki.blender.org/uploads/7/7c/BlenderHotkeysEditMode.png&quot; /&gt;&lt;/p&gt;
&lt;p&gt;一些简单的笔记&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Shift + S or Object/Mesh » Snap&lt;/li&gt;
&lt;li&gt;Ctrl J join 2 obj&lt;/li&gt;
&lt;li&gt;Alt C convert to mesh&lt;/li&gt;
&lt;li&gt;Ctrl P set parent&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;接下来打算再把 motion track 学学，找到个不错的&lt;a href=&quot;https://www.youtube.com/user/4ap21/playlists&quot;&gt;教程&lt;/a&gt;，能学这么多东西非常感谢这么多人的无私奉献。&lt;/p&gt;
&lt;p&gt;几个渲染出来的小图片：&lt;/p&gt;
&lt;h2 id=&quot;section&quot;&gt;&lt;img src=&quot;../../../../img/blender/noob/1.png&quot; /&gt;&lt;/h2&gt;
&lt;h2 id=&quot;section-1&quot;&gt;&lt;img src=&quot;../../../../img/blender/noob/2.png&quot; /&gt;&lt;/h2&gt;
&lt;h2 id=&quot;section-2&quot;&gt;&lt;img src=&quot;../../../../img/blender/noob/3.png&quot; /&gt;&lt;/h2&gt;
&lt;h2 id=&quot;section-3&quot;&gt;&lt;img src=&quot;../../../../img/blender/noob/4.jpg&quot; /&gt;&lt;/h2&gt;
&lt;h2 id=&quot;section-4&quot;&gt;&lt;img src=&quot;../../../../img/blender/noob/5.png&quot; /&gt;&lt;/h2&gt;
&lt;figure&gt;
&lt;img src=&quot;../../../../img/blender/noob/6.png&quot; /&gt;
&lt;/figure&gt;
&lt;p&gt;以及做了两个小动画：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;../../../../img/blender/noob/g1.gif&quot; /&gt; &lt;img src=&quot;../../../../img/blender/noob/g2.gif&quot; /&gt;&lt;/p&gt;
&lt;p&gt;用 Cycles Render 渲染的超级慢啊… 改天弄个渲染服务器试试&lt;/p&gt;
</description>
                <link>http://cjld.github.io/2014/06/11/blendercool</link>
                <guid>http://cjld.github.io/2014/06/11/blendercool</guid>
                <pubDate>2014-06-11T00:00:00+08:00</pubDate>
        </item>

        <item>
                <title>路漫漫</title>
                <description>&lt;p&gt;最近总算忙完 siga 了，深深的感觉到自己的不足之处，一个是英语，二是一些技能…&lt;/p&gt;
&lt;p&gt;有很多想做的，有很多想学的，无奈太懒计划总是落空，一大波期末考试要来了，再懒就要死了…&lt;/p&gt;
&lt;p&gt;还想积累一套做游戏的技能呢，从做音乐，美术，动画到各种nb引擎的使用， 什么时候才能实现呢？&lt;/p&gt;
&lt;p&gt;最近墙的好死啊，Google都抽了，什么时候才能无障碍的上油管呢，上面确实有很多精华呀。&lt;/p&gt;
</description>
                <link>http://cjld.github.io/2014/06/05/lotlearn</link>
                <guid>http://cjld.github.io/2014/06/05/lotlearn</guid>
                <pubDate>2014-06-05T00:00:00+08:00</pubDate>
        </item>

        <item>
                <title>std::vector's magic</title>
                <description>&lt;p&gt;一直对 stl 里的内存申请机制感到不解，写了这么一段代码做测试 ：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#include &amp;lt;vector&amp;gt;
#include &amp;lt;iostream&amp;gt;
#include &amp;lt;ctime&amp;gt;

using namespace std;

struct fly {
    static int hh;
    int x;
    
    fly() {
        x = hh++;
    }
    
};

int fly::hh = 0;

int main() {
    vector&amp;lt;fly&amp;gt; a;
    int n = 1000000;
    a.resize(n);
    long long tt;
    int s=0;

    tt = clock();
    for (int i=0; i&amp;lt;1000; i++) {
        a.clear();
        a.resize(n);
        s += a[0].x;
    }
    cout &amp;lt;&amp;lt; clock() - tt &amp;lt;&amp;lt; endl;

    tt = clock();
    for (int i=0; i&amp;lt;1000; i++) {
        vector&amp;lt;fly&amp;gt; a;
        a.clear();
        a.resize(n);
        s += a[0].x;
    }
    cout &amp;lt;&amp;lt; clock() - tt &amp;lt;&amp;lt; endl;

    tt = clock();
    for (int i=0; i&amp;lt;1000; i++) {
        fly* a = new fly[n];
        s += a[0].x;
        delete[] a;
    }
    cout &amp;lt;&amp;lt; clock() - tt &amp;lt;&amp;lt; &amp;quot; &amp;quot; &amp;lt;&amp;lt; s &amp;lt;&amp;lt; endl;
}&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;运行结果三个耗时依次是 662， 1534， 2856， 结果令我很意外。&lt;/p&gt;
&lt;p&gt;仔细的看了下 c++ reference， 发现所有 stl 容器里有一个不为人知的东西， &lt;a href=&quot;http://www.cplusplus.com/reference/memory/allocator/?kw=allocator&quot;&gt;allocator&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;似乎和我们平时理解的 new 不太一样，平时 new 一个元素，会首先为这个元素分配空间再调用构造函数， 而 allocator 则将这两部分开了， 有可能分配了空间却没有构造这个元素， 也有可能析构掉这个元素以后没有释放空间， 于是乎就出现了以上奇怪的运行结果。&lt;/p&gt;
</description>
                <link>http://cjld.github.io/2014/05/02/vectormagic</link>
                <guid>http://cjld.github.io/2014/05/02/vectormagic</guid>
                <pubDate>2014-05-02T00:00:00+08:00</pubDate>
        </item>

        <item>
                <title>写作业专用文档</title>
                <description>&lt;p&gt;平时用来写作业的 Document 模板&lt;/p&gt;
&lt;p&gt;就这样然后用 chrome 保存成 PDF，非常赞&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;/assets/pdfdoc/documenttest.pdf&quot;&gt;点这里围观&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;标题1&quot;&gt;标题1&lt;/h2&gt;
&lt;p&gt;&lt;span class=&quot;math&quot;&gt;\[ e^{i\pi} + 1 = 0 \]&lt;/span&gt;&lt;/p&gt;
&lt;h2 id=&quot;标题2&quot;&gt;标题2&lt;/h2&gt;
&lt;p&gt;公式 &lt;span class=&quot;math&quot;&gt;\(e^{i\pi} + 1 = 0\)&lt;/span&gt; 公式&lt;/p&gt;
&lt;p&gt;Relation &lt;span class=&quot;math&quot;&gt;\(R\)&lt;/span&gt; is &lt;span class=&quot;math&quot;&gt;\(xy\ge1\)&lt;/span&gt;, and &lt;span class=&quot;math&quot;&gt;\(x\in \mathbb{Z}\)&lt;/span&gt; and &lt;span class=&quot;math&quot;&gt;\(y\in\mathbb{Z}\)&lt;/span&gt;, is &lt;span class=&quot;math&quot;&gt;\(R\)&lt;/span&gt; reflexive?&lt;/p&gt;
&lt;h2 id=&quot;技巧&quot;&gt;技巧&lt;/h2&gt;
&lt;p&gt;这几个网页有讲关于打印的 CSS 属性：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/CSS/@page&quot;&gt;https://developer.mozilla.org/en-US/docs/Web/CSS/@page&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www.cocss.com/1564.html&quot;&gt;http://www.cocss.com/1564.html&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://dev.w3.org/csswg/css-page/#at-page-rule&quot;&gt;http://dev.w3.org/csswg/css-page/#at-page-rule&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;分个页试试&lt;/p&gt;
&lt;div class=&quot;page_break&quot;&gt;

&lt;/div&gt;
&lt;table&gt;
&lt;caption&gt;期末考试时间&lt;/caption&gt;
&lt;thead&gt;
&lt;tr class=&quot;header&quot;&gt;
&lt;th style=&quot;text-align: center;&quot;&gt;考试项目&lt;/th&gt;
&lt;th style=&quot;text-align: center;&quot;&gt;时间&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr class=&quot;odd&quot;&gt;
&lt;td style=&quot;text-align: center;&quot;&gt;复变函数&lt;/td&gt;
&lt;td style=&quot;text-align: center;&quot;&gt;1.8&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=&quot;even&quot;&gt;
&lt;td style=&quot;text-align: center;&quot;&gt;大物&lt;/td&gt;
&lt;td style=&quot;text-align: center;&quot;&gt;1.10&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=&quot;odd&quot;&gt;
&lt;td style=&quot;text-align: center;&quot;&gt;电子学基础&lt;/td&gt;
&lt;td style=&quot;text-align: center;&quot;&gt;1.16&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr class=&quot;header&quot;&gt;
&lt;th style=&quot;text-align: right;&quot;&gt;Right&lt;/th&gt;
&lt;th style=&quot;text-align: left;&quot;&gt;Left&lt;/th&gt;
&lt;th style=&quot;text-align: center;&quot;&gt;Center&lt;/th&gt;
&lt;th style=&quot;text-align: left;&quot;&gt;Default&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr class=&quot;odd&quot;&gt;
&lt;td style=&quot;text-align: right;&quot;&gt;12&lt;/td&gt;
&lt;td style=&quot;text-align: left;&quot;&gt;12&lt;/td&gt;
&lt;td style=&quot;text-align: center;&quot;&gt;12&lt;/td&gt;
&lt;td style=&quot;text-align: left;&quot;&gt;12&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=&quot;even&quot;&gt;
&lt;td style=&quot;text-align: right;&quot;&gt;123&lt;/td&gt;
&lt;td style=&quot;text-align: left;&quot;&gt;123&lt;/td&gt;
&lt;td style=&quot;text-align: center;&quot;&gt;123&lt;/td&gt;
&lt;td style=&quot;text-align: left;&quot;&gt;123&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=&quot;odd&quot;&gt;
&lt;td style=&quot;text-align: right;&quot;&gt;1&lt;/td&gt;
&lt;td style=&quot;text-align: left;&quot;&gt;1&lt;/td&gt;
&lt;td style=&quot;text-align: center;&quot;&gt;1&lt;/td&gt;
&lt;td style=&quot;text-align: left;&quot;&gt;1&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;hr /&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;style type=&amp;quot;text/css&amp;quot;&amp;gt;
.navbar {
    display : none;
}

#tags_box {
    display : none;
}

.pagination {
    display : none;
}
&amp;lt;/style&amp;gt;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;试试&lt;/p&gt;
&lt;h2 id=&quot;技巧-1&quot;&gt;技巧&lt;/h2&gt;
&lt;p&gt;就这样然后用 chrome 保存成 PDF，非常赞&lt;/p&gt;
&lt;table&gt;
&lt;caption&gt;期末考试时间&lt;/caption&gt;
&lt;thead&gt;
&lt;tr class=&quot;header&quot;&gt;
&lt;th style=&quot;text-align: center;&quot;&gt;考试项目&lt;/th&gt;
&lt;th style=&quot;text-align: center;&quot;&gt;时间&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr class=&quot;odd&quot;&gt;
&lt;td style=&quot;text-align: center;&quot;&gt;复变函数&lt;/td&gt;
&lt;td style=&quot;text-align: center;&quot;&gt;1.8&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=&quot;even&quot;&gt;
&lt;td style=&quot;text-align: center;&quot;&gt;大物&lt;/td&gt;
&lt;td style=&quot;text-align: center;&quot;&gt;1.10&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=&quot;odd&quot;&gt;
&lt;td style=&quot;text-align: center;&quot;&gt;电子学基础&lt;/td&gt;
&lt;td style=&quot;text-align: center;&quot;&gt;1.16&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr class=&quot;header&quot;&gt;
&lt;th style=&quot;text-align: right;&quot;&gt;Right&lt;/th&gt;
&lt;th style=&quot;text-align: left;&quot;&gt;Left&lt;/th&gt;
&lt;th style=&quot;text-align: center;&quot;&gt;Center&lt;/th&gt;
&lt;th style=&quot;text-align: left;&quot;&gt;Default&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr class=&quot;odd&quot;&gt;
&lt;td style=&quot;text-align: right;&quot;&gt;12&lt;/td&gt;
&lt;td style=&quot;text-align: left;&quot;&gt;12&lt;/td&gt;
&lt;td style=&quot;text-align: center;&quot;&gt;12&lt;/td&gt;
&lt;td style=&quot;text-align: left;&quot;&gt;12&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=&quot;even&quot;&gt;
&lt;td style=&quot;text-align: right;&quot;&gt;123&lt;/td&gt;
&lt;td style=&quot;text-align: left;&quot;&gt;123&lt;/td&gt;
&lt;td style=&quot;text-align: center;&quot;&gt;123&lt;/td&gt;
&lt;td style=&quot;text-align: left;&quot;&gt;123&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=&quot;odd&quot;&gt;
&lt;td style=&quot;text-align: right;&quot;&gt;1&lt;/td&gt;
&lt;td style=&quot;text-align: left;&quot;&gt;1&lt;/td&gt;
&lt;td style=&quot;text-align: center;&quot;&gt;1&lt;/td&gt;
&lt;td style=&quot;text-align: left;&quot;&gt;1&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;hr /&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;style type=&amp;quot;text/css&amp;quot;&amp;gt;
.navbar {
    display : none;
}

#tags_box {
    display : none;
}

.pagination {
    display : none;
}
&amp;lt;/style&amp;gt;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;试试&lt;/p&gt;
&lt;h2 id=&quot;技巧-2&quot;&gt;技巧&lt;/h2&gt;
&lt;p&gt;就这样然后用 chrome 保存成 PDF，非常赞&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#include &amp;lt;iostream&amp;gt;
#include &amp;lt;Eigen/Core&amp;gt;
#include &amp;lt;Eigen/Dense&amp;gt;
#include &amp;lt;Eigen/Eigen&amp;gt;
#include &amp;lt;Eigen/SVD&amp;gt;

using namespace std;
using namespace Eigen;

#define FOR(i,l,r) for (int i=(l); i&amp;lt;=(r); i++)

int main() {
    Vector4d v1;
    v1 &amp;lt;&amp;lt; 1, 2, 3, 4;
    cout &amp;lt;&amp;lt; &amp;quot;v1 = \n&amp;quot; &amp;lt;&amp;lt; v1 &amp;lt;&amp;lt; endl;
    cout &amp;lt;&amp;lt; &amp;quot;v1.cols() &amp;quot; &amp;lt;&amp;lt; v1.cols() &amp;lt;&amp;lt; &amp;quot; v1.rows() &amp;quot; &amp;lt;&amp;lt; v1.rows() &amp;lt;&amp;lt; endl;
    cout &amp;lt;&amp;lt; v1(1) &amp;lt;&amp;lt; v1(1,0) &amp;lt;&amp;lt; endl;

    VectorXd v2(2);
    v2 &amp;lt;&amp;lt; 8, 9;
    cout &amp;lt;&amp;lt; &amp;quot;v2 = \n&amp;quot; &amp;lt;&amp;lt; v2 &amp;lt;&amp;lt; endl;

    cout &amp;lt;&amp;lt; &amp;quot;test matrix&amp;quot; &amp;lt;&amp;lt; endl;

    MatrixXf m1(2,5);
    FOR(i,0,m1.rows()-1) FOR(j,0,m1.cols()-1) m1(i,j) = i*10+j;
    cout &amp;lt;&amp;lt; &amp;quot;m1 =\n&amp;quot; &amp;lt;&amp;lt; m1 &amp;lt;&amp;lt; endl;

    int rows=5;
    int cols=5;
    MatrixXf m2(rows,cols);
    m2&amp;lt;&amp;lt;( Matrix3f()&amp;lt;&amp;lt;1,2,3,4,5,6,7,8,10 ).finished(),
        MatrixXf::Zero(3,cols-3),
        MatrixXf::Zero(rows-3,3),
        MatrixXf::Identity(rows-3,cols-3);
    cout&amp;lt;&amp;lt;&amp;quot;m2=\n&amp;quot;&amp;lt;&amp;lt;m2&amp;lt;&amp;lt;endl;

    cout&amp;lt;&amp;lt; m1*m2 &amp;lt;&amp;lt;endl;

    cout&amp;lt;&amp;lt;&amp;quot;转置&amp;quot;&amp;lt;&amp;lt;endl;
    cout &amp;lt;&amp;lt; m2.transpose() * m1.transpose() &amp;lt;&amp;lt; endl;

    cout&amp;lt;&amp;lt;&amp;quot;对每个元素执行 cos&amp;quot;&amp;lt;&amp;lt;endl;
    cout &amp;lt;&amp;lt; m2.array().cos() &amp;lt;&amp;lt; endl;

    cout&amp;lt;&amp;lt;&amp;quot;行列式&amp;quot;&amp;lt;&amp;lt;endl;
    cout &amp;lt;&amp;lt; m2.determinant() &amp;lt;&amp;lt; endl;

    cout&amp;lt;&amp;lt;&amp;quot;特征向量&amp;quot;&amp;lt;&amp;lt;endl;
    EigenSolver&amp;lt;decltype(m2)&amp;gt; es(m2);
    cout &amp;lt;&amp;lt; es.eigenvectors() &amp;lt;&amp;lt; endl;

    cout&amp;lt;&amp;lt;&amp;quot;特征值&amp;quot;&amp;lt;&amp;lt;endl;
    cout &amp;lt;&amp;lt; es.eigenvalues() &amp;lt;&amp;lt; endl;

    cout&amp;lt;&amp;lt;&amp;quot;特征值分解 V*D*V^(-1)&amp;quot;&amp;lt;&amp;lt;endl;
    cout &amp;lt;&amp;lt; es.eigenvectors() * es.eigenvalues().asDiagonal() * es.eigenvectors().inverse() &amp;lt;&amp;lt; endl;

    cout&amp;lt;&amp;lt;&amp;quot;SVD 分解&amp;quot;&amp;lt;&amp;lt;endl;
    JacobiSVD&amp;lt;decltype(m2)&amp;gt; svd(m2, ComputeThinU | ComputeThinV);
    cout &amp;lt;&amp;lt; svd.matrixU().determinant() &amp;lt;&amp;lt; endl &amp;lt;&amp;lt; svd.singularValues() &amp;lt;&amp;lt; endl &amp;lt;&amp;lt; svd.matrixV().determinant() &amp;lt;&amp;lt; endl;
    cout &amp;lt;&amp;lt; svd.matrixU() * svd.singularValues().asDiagonal() * svd.matrixV().transpose() &amp;lt;&amp;lt; endl;
    cout&amp;lt;&amp;lt;&amp;quot;SVD 解最小二乘&amp;quot;&amp;lt;&amp;lt;endl;
    cout &amp;lt;&amp;lt; svd.solve(VectorXf::Ones(5));

    cout&amp;lt;&amp;lt;&amp;quot;极分解&amp;quot;&amp;lt;&amp;lt;endl;
    auto rot = svd.matrixU() * svd.matrixV().transpose();
    auto scl = svd.matrixV() * svd.singularValues().asDiagonal() * svd.matrixV().transpose();
    cout&amp;lt;&amp;lt;rot&amp;lt;&amp;lt;endl&amp;lt;&amp;lt;scl&amp;lt;&amp;lt;endl;
    cout&amp;lt;&amp;lt;rot.determinant()&amp;lt;&amp;lt;endl&amp;lt;&amp;lt;rot*scl&amp;lt;&amp;lt;endl;

    cout&amp;lt;&amp;lt;&amp;quot;齐次坐标&amp;quot;&amp;lt;&amp;lt;endl;
    Transform&amp;lt;float, 5, Affine&amp;gt; trans;
    //trans.computeRotationScaling();
    cout &amp;lt;&amp;lt; trans.matrix() &amp;lt;&amp;lt; endl;

    cout&amp;lt;&amp;lt;&amp;quot;解线性方程&amp;quot;&amp;lt;&amp;lt;endl;
    VectorXf v(5);
    v &amp;lt;&amp;lt; 1,2,4,3,5;
    cout&amp;lt;&amp;lt;MatrixXf(v.asDiagonal()).colPivHouseholderQr().solve(VectorXf::Ones(5))&amp;lt;&amp;lt;endl;
}&lt;/code&gt;&lt;/pre&gt;
&lt;table&gt;
&lt;caption&gt;期末考试时间&lt;/caption&gt;
&lt;thead&gt;
&lt;tr class=&quot;header&quot;&gt;
&lt;th style=&quot;text-align: center;&quot;&gt;考试项目&lt;/th&gt;
&lt;th style=&quot;text-align: center;&quot;&gt;时间&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr class=&quot;odd&quot;&gt;
&lt;td style=&quot;text-align: center;&quot;&gt;复变函数&lt;/td&gt;
&lt;td style=&quot;text-align: center;&quot;&gt;1.8&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=&quot;even&quot;&gt;
&lt;td style=&quot;text-align: center;&quot;&gt;大物&lt;/td&gt;
&lt;td style=&quot;text-align: center;&quot;&gt;1.10&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=&quot;odd&quot;&gt;
&lt;td style=&quot;text-align: center;&quot;&gt;电子学基础&lt;/td&gt;
&lt;td style=&quot;text-align: center;&quot;&gt;1.16&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr class=&quot;header&quot;&gt;
&lt;th style=&quot;text-align: right;&quot;&gt;Right&lt;/th&gt;
&lt;th style=&quot;text-align: left;&quot;&gt;Left&lt;/th&gt;
&lt;th style=&quot;text-align: center;&quot;&gt;Center&lt;/th&gt;
&lt;th style=&quot;text-align: left;&quot;&gt;Default&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr class=&quot;odd&quot;&gt;
&lt;td style=&quot;text-align: right;&quot;&gt;12&lt;/td&gt;
&lt;td style=&quot;text-align: left;&quot;&gt;12&lt;/td&gt;
&lt;td style=&quot;text-align: center;&quot;&gt;12&lt;/td&gt;
&lt;td style=&quot;text-align: left;&quot;&gt;12&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=&quot;even&quot;&gt;
&lt;td style=&quot;text-align: right;&quot;&gt;123&lt;/td&gt;
&lt;td style=&quot;text-align: left;&quot;&gt;123&lt;/td&gt;
&lt;td style=&quot;text-align: center;&quot;&gt;123&lt;/td&gt;
&lt;td style=&quot;text-align: left;&quot;&gt;123&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=&quot;odd&quot;&gt;
&lt;td style=&quot;text-align: right;&quot;&gt;1&lt;/td&gt;
&lt;td style=&quot;text-align: left;&quot;&gt;1&lt;/td&gt;
&lt;td style=&quot;text-align: center;&quot;&gt;1&lt;/td&gt;
&lt;td style=&quot;text-align: left;&quot;&gt;1&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;hr /&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;style type=&amp;quot;text/css&amp;quot;&amp;gt;
.navbar {
    display : none;
}

#tags_box {
    display : none;
}

.pagination {
    display : none;
}
&amp;lt;/style&amp;gt;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;试试&lt;/p&gt;
&lt;h2 id=&quot;技巧-3&quot;&gt;技巧&lt;/h2&gt;
&lt;p&gt;就这样然后用 chrome 保存成 PDF，非常赞&lt;/p&gt;
&lt;table&gt;
&lt;caption&gt;期末考试时间&lt;/caption&gt;
&lt;thead&gt;
&lt;tr class=&quot;header&quot;&gt;
&lt;th style=&quot;text-align: center;&quot;&gt;考试项目&lt;/th&gt;
&lt;th style=&quot;text-align: center;&quot;&gt;时间&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr class=&quot;odd&quot;&gt;
&lt;td style=&quot;text-align: center;&quot;&gt;复变函数&lt;/td&gt;
&lt;td style=&quot;text-align: center;&quot;&gt;1.8&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=&quot;even&quot;&gt;
&lt;td style=&quot;text-align: center;&quot;&gt;大物&lt;/td&gt;
&lt;td style=&quot;text-align: center;&quot;&gt;1.10&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=&quot;odd&quot;&gt;
&lt;td style=&quot;text-align: center;&quot;&gt;电子学基础&lt;/td&gt;
&lt;td style=&quot;text-align: center;&quot;&gt;1.16&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr class=&quot;header&quot;&gt;
&lt;th style=&quot;text-align: right;&quot;&gt;Right&lt;/th&gt;
&lt;th style=&quot;text-align: left;&quot;&gt;Left&lt;/th&gt;
&lt;th style=&quot;text-align: center;&quot;&gt;Center&lt;/th&gt;
&lt;th style=&quot;text-align: left;&quot;&gt;Default&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr class=&quot;odd&quot;&gt;
&lt;td style=&quot;text-align: right;&quot;&gt;12&lt;/td&gt;
&lt;td style=&quot;text-align: left;&quot;&gt;12&lt;/td&gt;
&lt;td style=&quot;text-align: center;&quot;&gt;12&lt;/td&gt;
&lt;td style=&quot;text-align: left;&quot;&gt;12&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=&quot;even&quot;&gt;
&lt;td style=&quot;text-align: right;&quot;&gt;123&lt;/td&gt;
&lt;td style=&quot;text-align: left;&quot;&gt;123&lt;/td&gt;
&lt;td style=&quot;text-align: center;&quot;&gt;123&lt;/td&gt;
&lt;td style=&quot;text-align: left;&quot;&gt;123&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=&quot;odd&quot;&gt;
&lt;td style=&quot;text-align: right;&quot;&gt;1&lt;/td&gt;
&lt;td style=&quot;text-align: left;&quot;&gt;1&lt;/td&gt;
&lt;td style=&quot;text-align: center;&quot;&gt;1&lt;/td&gt;
&lt;td style=&quot;text-align: left;&quot;&gt;1&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;hr /&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;style type=&amp;quot;text/css&amp;quot;&amp;gt;
.navbar {
    display : none;
}

#tags_box {
    display : none;
}

.pagination {
    display : none;
}
&amp;lt;/style&amp;gt;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;试试&lt;/p&gt;
</description>
                <link>http://cjld.github.io/2014/04/10/documenttest</link>
                <guid>http://cjld.github.io/2014/04/10/documenttest</guid>
                <pubDate>2014-04-10T00:00:00+08:00</pubDate>
        </item>

        <item>
                <title>Unity 在导入模型时点数发生改变</title>
                <description>&lt;p&gt;最近要利用 Unity 做一些关于 mesh 的变形，但是却出现了一些问题，发现原来的 obj 文件有 n 个点，导入到 Unity 中却变多了…&lt;/p&gt;
&lt;p&gt;事后找到原因，原来是 Unity 在导入模型时，会把具有不同法向量的点拆分成几个点，因此点数就变多了，解决方法是在导入模型设置里把 Normals 改为 None&lt;/p&gt;
&lt;p&gt;这篇文章好水… 我纯粹是来凑文章数的 = =&lt;/p&gt;
</description>
                <link>http://cjld.github.io/2014/03/30/unitychangevertex</link>
                <guid>http://cjld.github.io/2014/03/30/unitychangevertex</guid>
                <pubDate>2014-03-30T00:00:00+08:00</pubDate>
        </item>

        <item>
                <title>Eigen 试用</title>
                <description>&lt;p&gt;最近要做一些和矩阵有关的运算， 因为 matlab 实在用不习惯，找了个比较轻量的 Eigen，轻量到都不需要链接，赞吧~&lt;/p&gt;
&lt;p&gt;特征值，SVD分解都有，解线性方程，最小二乘都没问题。&lt;/p&gt;
&lt;p&gt;似乎还有些针对稀疏矩阵的优化，不过用不着。&lt;/p&gt;
&lt;p&gt;一段简单的 code :&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#include &amp;lt;iostream&amp;gt;
#include &amp;lt;Eigen/Core&amp;gt;
#include &amp;lt;Eigen/Dense&amp;gt;
#include &amp;lt;Eigen/Eigen&amp;gt;
#include &amp;lt;Eigen/SVD&amp;gt;

using namespace std;
using namespace Eigen;

#define FOR(i,l,r) for (int i=(l); i&amp;lt;=(r); i++)

int main() {
    Vector4d v1;
    v1 &amp;lt;&amp;lt; 1, 2, 3, 4;
    cout &amp;lt;&amp;lt; &amp;quot;v1 = \n&amp;quot; &amp;lt;&amp;lt; v1 &amp;lt;&amp;lt; endl;
    cout &amp;lt;&amp;lt; &amp;quot;v1.cols() &amp;quot; &amp;lt;&amp;lt; v1.cols() &amp;lt;&amp;lt; &amp;quot; v1.rows() &amp;quot; &amp;lt;&amp;lt; v1.rows() &amp;lt;&amp;lt; endl;
    cout &amp;lt;&amp;lt; v1(1) &amp;lt;&amp;lt; v1(1,0) &amp;lt;&amp;lt; endl;

    VectorXd v2(2);
    v2 &amp;lt;&amp;lt; 8, 9;
    cout &amp;lt;&amp;lt; &amp;quot;v2 = \n&amp;quot; &amp;lt;&amp;lt; v2 &amp;lt;&amp;lt; endl;

    cout &amp;lt;&amp;lt; &amp;quot;test matrix&amp;quot; &amp;lt;&amp;lt; endl;

    MatrixXf m1(2,5);
    FOR(i,0,m1.rows()-1) FOR(j,0,m1.cols()-1) m1(i,j) = i*10+j;
    cout &amp;lt;&amp;lt; &amp;quot;m1 =\n&amp;quot; &amp;lt;&amp;lt; m1 &amp;lt;&amp;lt; endl;

    int rows=5;
    int cols=5;
    MatrixXf m2(rows,cols);
    m2&amp;lt;&amp;lt;( Matrix3f()&amp;lt;&amp;lt;1,2,3,4,5,6,7,8,10 ).finished(),
        MatrixXf::Zero(3,cols-3),
        MatrixXf::Zero(rows-3,3),
        MatrixXf::Identity(rows-3,cols-3);
    cout&amp;lt;&amp;lt;&amp;quot;m2=\n&amp;quot;&amp;lt;&amp;lt;m2&amp;lt;&amp;lt;endl;

    cout&amp;lt;&amp;lt; m1*m2 &amp;lt;&amp;lt;endl;

    cout&amp;lt;&amp;lt;&amp;quot;转置&amp;quot;&amp;lt;&amp;lt;endl;
    cout &amp;lt;&amp;lt; m2.transpose() * m1.transpose() &amp;lt;&amp;lt; endl;

    cout&amp;lt;&amp;lt;&amp;quot;对每个元素执行 cos&amp;quot;&amp;lt;&amp;lt;endl;
    cout &amp;lt;&amp;lt; m2.array().cos() &amp;lt;&amp;lt; endl;

    cout&amp;lt;&amp;lt;&amp;quot;行列式&amp;quot;&amp;lt;&amp;lt;endl;
    cout &amp;lt;&amp;lt; m2.determinant() &amp;lt;&amp;lt; endl;

    cout&amp;lt;&amp;lt;&amp;quot;特征向量&amp;quot;&amp;lt;&amp;lt;endl;
    EigenSolver&amp;lt;decltype(m2)&amp;gt; es(m2);
    cout &amp;lt;&amp;lt; es.eigenvectors() &amp;lt;&amp;lt; endl;

    cout&amp;lt;&amp;lt;&amp;quot;特征值&amp;quot;&amp;lt;&amp;lt;endl;
    cout &amp;lt;&amp;lt; es.eigenvalues() &amp;lt;&amp;lt; endl;

    cout&amp;lt;&amp;lt;&amp;quot;特征值分解 V*D*V^(-1)&amp;quot;&amp;lt;&amp;lt;endl;
    cout &amp;lt;&amp;lt; es.eigenvectors() * es.eigenvalues().asDiagonal() * es.eigenvectors().inverse() &amp;lt;&amp;lt; endl;

    cout&amp;lt;&amp;lt;&amp;quot;SVD 分解&amp;quot;&amp;lt;&amp;lt;endl;
    JacobiSVD&amp;lt;decltype(m2)&amp;gt; svd(m2, ComputeThinU | ComputeThinV);
    cout &amp;lt;&amp;lt; svd.matrixU().determinant() &amp;lt;&amp;lt; endl &amp;lt;&amp;lt; svd.singularValues() &amp;lt;&amp;lt; endl &amp;lt;&amp;lt; svd.matrixV().determinant() &amp;lt;&amp;lt; endl;
    cout &amp;lt;&amp;lt; svd.matrixU() * svd.singularValues().asDiagonal() * svd.matrixV().transpose() &amp;lt;&amp;lt; endl;
    cout&amp;lt;&amp;lt;&amp;quot;SVD 解最小二乘&amp;quot;&amp;lt;&amp;lt;endl;
    cout &amp;lt;&amp;lt; svd.solve(VectorXf::Ones(5));

    cout&amp;lt;&amp;lt;&amp;quot;极分解&amp;quot;&amp;lt;&amp;lt;endl;
    auto rot = svd.matrixU() * svd.matrixV().transpose();
    auto scl = svd.matrixV() * svd.singularValues().asDiagonal() * svd.matrixV().transpose();
    cout&amp;lt;&amp;lt;rot&amp;lt;&amp;lt;endl&amp;lt;&amp;lt;scl&amp;lt;&amp;lt;endl;
    cout&amp;lt;&amp;lt;rot.determinant()&amp;lt;&amp;lt;endl&amp;lt;&amp;lt;rot*scl&amp;lt;&amp;lt;endl;

    cout&amp;lt;&amp;lt;&amp;quot;齐次坐标&amp;quot;&amp;lt;&amp;lt;endl;
    Transform&amp;lt;float, 5, Affine&amp;gt; trans;
    //trans.computeRotationScaling();
    cout &amp;lt;&amp;lt; trans.matrix() &amp;lt;&amp;lt; endl;

    cout&amp;lt;&amp;lt;&amp;quot;解线性方程&amp;quot;&amp;lt;&amp;lt;endl;
    VectorXf v(5);
    v &amp;lt;&amp;lt; 1,2,4,3,5;
    cout&amp;lt;&amp;lt;MatrixXf(v.asDiagonal()).colPivHouseholderQr().solve(VectorXf::Ones(5))&amp;lt;&amp;lt;endl;
}&lt;/code&gt;&lt;/pre&gt;
</description>
                <link>http://cjld.github.io/2014/03/27/tryeigen</link>
                <guid>http://cjld.github.io/2014/03/27/tryeigen</guid>
                <pubDate>2014-03-27T00:00:00+08:00</pubDate>
        </item>

        <item>
                <title>mipMap 导致的诡异 Bug</title>
                <description>&lt;p&gt;今天在用 RenderTexture 实现战争迷雾的时候出现了诡异的 Bug， 最后胡乱的把这个 Bug 修复了， Bug 如下：&lt;/p&gt;
&lt;figure&gt;
&lt;img src=&quot;../../../../img/mipmapbug/1.png&quot; /&gt;
&lt;/figure&gt;
&lt;hr /&gt;
&lt;p&gt;右下是战争迷雾贴图，可以看到图中边缘处出现了莫名其妙的黑边。&lt;/p&gt;
&lt;p&gt;一开始是以为 depth buffer 的精度出了问题， 各种输出调试无果以后，偶然的偶然的修改了迷雾贴图的 FilterMode 以后黑边的分布出现变化， 在 Texture 高级选项中禁用 mipmap 以后 bug 修复， 原因是因为在某些边远地方直接使用了最小级别的 mipmap，而最小级别的 mipmap 颜色并不是透明的，导致出现 bug。&lt;/p&gt;
&lt;figure&gt;
&lt;img src=&quot;../../../../img/mipmapbug/2.png&quot; /&gt;
&lt;/figure&gt;
&lt;hr /&gt;
&lt;p&gt;有一点无法理解的是， 使用 RenderTexture 应该会丢失层次细节的， Unity3D 是怎么样找到需要使用 mipmap 的地方的？ 难道储存了每个像素的 LOD 么 = =&lt;/p&gt;
</description>
                <link>http://cjld.github.io/2014/02/22/mipmapbug</link>
                <guid>http://cjld.github.io/2014/02/22/mipmapbug</guid>
                <pubDate>2014-02-22T00:00:00+08:00</pubDate>
        </item>

        <item>
                <title>Unity3D 初探</title>
                <description>&lt;p&gt;又好久没有更新 BLOG 了, 一定要坚持一个月至少一篇, 于是乎我又来记流水账了, 这一次就讲讲这一周折腾 Unity3D 的情况吧.&lt;/p&gt;
&lt;p&gt;学习资料网上搜一大把, 主要学习资料来自于下面几个网站:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://www.unitymanual.com/topic/download/index.html&quot;&gt;http://www.unitymanual.com/topic/download/index.html&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www.xuanyusong.com/&quot;&gt;http://www.xuanyusong.com/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://docs.unity3d.com/Documentation/ScriptReference/&quot;&gt;https://docs.unity3d.com/Documentation/ScriptReference/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://game.ceeger.com/Components/SL-Reference.html&quot;&gt;http://game.ceeger.com/Components/SL-Reference.html&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www.youtube.com/watch?v=hDJQXzajiPg&quot;&gt;http://www.youtube.com/watch?v=hDJQXzajiPg&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;如果能系统的学习完还打算去官方下几个 demo 认真研究下.&lt;/p&gt;
&lt;h3 id=&quot;对于-unity3d-的吐槽&quot;&gt;对于 Unity3D 的吐槽&lt;/h3&gt;
&lt;p&gt;Unity3D 这个引擎, 上手还是比较简单的, 这得益于其编辑器, 用起来非常舒服, 几乎不用写代码就能够做出炫酷的效果, 代码上会点 javascript 就能完成很多事情, 可以说是非常的照顾设计师了. 因此网上的很多教程也比较偏向于设计师, 这让我有些许困惑, 作为程序员, 还是希望一切都能够用代码来控制, 好在编辑器能做到的绝大多数事情直接用代码也能做到, 但好像还是有些做不到需要用一些更复杂的代码甚至插件来实现.&lt;/p&gt;
&lt;p&gt;不过 Unity 真心是一个非常赞的引擎, 认真查阅文档的话想做还是能做到的, 现在的 Unity3D 社区也非常活跃, 不过这玩意还真是贵, 貌似专业版要用 1500 刀.&lt;/p&gt;
&lt;p&gt;在 Unity 里面写 shader 挺舒服的.&lt;/p&gt;
&lt;p&gt;以上是一个新手不负责任的吐槽&lt;/p&gt;
&lt;h3 id=&quot;对于-csharp-的吐槽&quot;&gt;对于 CSharp 的吐槽&lt;/h3&gt;
&lt;p&gt;CSharp 原来就是 C#, 我真是孤陋寡闻了, C# 的来源是 C++ 中的两个加号叠在一起, 巨硬的脑洞还真是大.&lt;/p&gt;
&lt;p&gt;指针这个概念被取消掉还真是让人难受… struct 的等于号是拷贝而 class 的等号是传引用这还真是让人纠结, 万一我不知道我当前用的到底是 struct 还是 class 怎么破.&lt;/p&gt;
&lt;p&gt;还有 托管(delegate) 和 事件(event), 为什么感觉就是函数指针和函数指针数组……&lt;/p&gt;
&lt;p&gt;已经不太想去纠结语言特性了, 反正我就是吧它当 C++ 来用的, 以后上 java 小学期的时候再认真研究研究.&lt;/p&gt;
&lt;h3 id=&quot;学习笔记&quot;&gt;学习笔记&lt;/h3&gt;
&lt;p&gt;涂鸦式的笔记, 用这种大型软件需要积累的豆知识太多了, 随手记一下到时候也好查&lt;/p&gt;
&lt;h4 id=&quot;day1&quot;&gt;day1&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;导入模型与动画&lt;/li&gt;
&lt;li&gt;自带的材质与着色器的使用，高光，mip等等&lt;/li&gt;
&lt;li&gt;GUI按钮，纹理&lt;/li&gt;
&lt;li&gt;立体声音与脚本控制&lt;/li&gt;
&lt;li&gt;脚本创建物体，预设instantiate创建物体&lt;/li&gt;
&lt;li&gt;favorite保存搜索结果书签 多关键字搜索&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&quot;day2&quot;&gt;day2&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;阴影要同时在投射者，接受者，灯光处设置&lt;/li&gt;
&lt;li&gt;选择多个同时调整&lt;/li&gt;
&lt;li&gt;lock Inspector 让其固定显示一物体&lt;/li&gt;
&lt;li&gt;Debug 可以查看脚本中的私有变量&lt;/li&gt;
&lt;li&gt;右上角创建 tab, shift + tab 最大化当前 tab&lt;/li&gt;
&lt;li&gt;场景浏览
&lt;ul&gt;
&lt;li&gt;方向键移动&lt;/li&gt;
&lt;li&gt;中键&lt;/li&gt;
&lt;li&gt;右键切换视角 + WASD&lt;/li&gt;
&lt;li&gt;shift 加速&lt;/li&gt;
&lt;li&gt;选择物体 F 到显示中心&lt;/li&gt;
&lt;li&gt;alt+左键，绕物体旋转&lt;/li&gt;
&lt;li&gt;shift + ctrl 吸附移动&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;getComponent(type)&lt;/li&gt;
&lt;li&gt;GameObject.Find(name)&lt;/li&gt;
&lt;li&gt;GameObject.FindGameObject(s)WithTag(tagname)&lt;/li&gt;
&lt;li&gt;Time
&lt;ul&gt;
&lt;li&gt;Time.time&lt;/li&gt;
&lt;li&gt;Time.deltaTime&lt;/li&gt;
&lt;li&gt;Time.fixedTime&lt;/li&gt;
&lt;li&gt;fixedDeltaTime&lt;/li&gt;
&lt;li&gt;smoothDeltaTime&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;yield WaitForSeconds&lt;/li&gt;
&lt;li&gt;gameObject.sendMessage&lt;/li&gt;
&lt;li&gt;CSharp 中的 delegate/event&lt;/li&gt;
&lt;li&gt;OnMouseOver 重载&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&quot;day3&quot;&gt;day3&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;OnGUI 调用频率为每秒120次，高于刷新频率&lt;/li&gt;
&lt;li&gt;各种可重载函数&lt;/li&gt;
&lt;li&gt;Screen 类&lt;/li&gt;
&lt;li&gt;Group Box&lt;/li&gt;
&lt;li&gt;GUILayout
&lt;ul&gt;
&lt;li&gt;BeginHorizontal&lt;/li&gt;
&lt;li&gt;Space&lt;/li&gt;
&lt;li&gt;GUILayoutOption&lt;/li&gt;
&lt;li&gt;GUILayout.Width GUILayout.MinWidth GUILayout.ExpandHeight.&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;C# 特性
&lt;ul&gt;
&lt;li&gt;params 可变参数&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;GUILayout.BeginArea(Rect)&lt;/li&gt;
&lt;li&gt;GUI.Window
&lt;ul&gt;
&lt;li&gt;GUI.DragWindow&lt;/li&gt;
&lt;li&gt;无法拖动窗口主要因为位置设置&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&quot;day4&quot;&gt;day4&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;TerrainData.Alphamaps 设置贴图混合&lt;/li&gt;
&lt;li&gt;setHeights&lt;/li&gt;
&lt;li&gt;heightMapScale&lt;/li&gt;
&lt;li&gt;GetSteepness 获得斜率&lt;/li&gt;
&lt;li&gt;GetInterpolatedHeight 高度插值&lt;/li&gt;
&lt;li&gt;C# 扩展方法 要static，this第一个参数&lt;/li&gt;
&lt;li&gt;Resource.Load&lt;/li&gt;
&lt;li&gt;TerrainData.splatPrototypes 添加纹理&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&quot;day5&quot;&gt;day5&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;Input.GetAxis 虚拟轴 平滑&lt;/li&gt;
&lt;li&gt;GameObject.CreatePrimitive(PrimitiveType.Cube)&lt;/li&gt;
&lt;li&gt;Input.GetMouseButton 0 l 1 r 2 m&lt;/li&gt;
&lt;li&gt;Input.GetKey KeyCode.UpArrow&lt;/li&gt;
&lt;li&gt;Rigidbody
&lt;ul&gt;
&lt;li&gt;MovePosition&lt;/li&gt;
&lt;li&gt;AddForce&lt;/li&gt;
&lt;li&gt;velocity&lt;/li&gt;
&lt;li&gt;angularVelocity&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Destroy&lt;/li&gt;
&lt;li&gt;Event.clickCount&lt;/li&gt;
&lt;li&gt;Event 各种功能键&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&quot;day6&quot;&gt;day6&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;Character Controllers&lt;/li&gt;
&lt;li&gt;Animation Curve&lt;/li&gt;
&lt;li&gt;Rigidbody
&lt;ul&gt;
&lt;li&gt;CollisionDetection&lt;/li&gt;
&lt;li&gt;OnTriggerStay&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Debug.DrawRay&lt;/li&gt;
&lt;li&gt;HingeJoint SpringJoint FixedJoint&lt;/li&gt;
&lt;li&gt;CharacterJoint swing + twist&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&quot;day7&quot;&gt;day7&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;iTween 平滑人物移动&lt;/li&gt;
&lt;li&gt;Pocket RPG Weapon Trails 移动痕迹 Trail Render&lt;/li&gt;
&lt;li&gt;camera.WorldToScreenPoint&lt;/li&gt;
&lt;li&gt;InteractiveCloth and SkinnedCloth&lt;/li&gt;
&lt;li&gt;ParticleSystem.Emit&lt;/li&gt;
&lt;li&gt;ParticleSystemRenderer.velocityScale&lt;/li&gt;
&lt;li&gt;OnParticleSystemCollision 在world下生效 双方&lt;/li&gt;
&lt;li&gt;ParticleSystemRender&lt;/li&gt;
&lt;li&gt;skybox 加在摄像机上&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&quot;day8&quot;&gt;day8&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;TreeCreator&lt;/li&gt;
&lt;li&gt;WindZone&lt;/li&gt;
&lt;li&gt;Screentoray 左下角0,0 而mousepos为左上角0,0&lt;/li&gt;
&lt;li&gt;Flare&lt;/li&gt;
&lt;li&gt;WrapMode
&lt;ul&gt;
&lt;li&gt;Once 结束固定在第一帧&lt;/li&gt;
&lt;li&gt;ClampForever 结束固定在最后一帧&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Animation.enable&lt;/li&gt;
&lt;li&gt;Animation.Layer 动画层 优先级&lt;/li&gt;
&lt;li&gt;Animation.AddClip&lt;/li&gt;
&lt;li&gt;Animation.CrossFade&lt;/li&gt;
&lt;li&gt;AnimationBlendMode.Additive&lt;/li&gt;
&lt;li&gt;ragdoll 就只自动添加物理部件&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&quot;day9&quot;&gt;day9&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;Shader Properties 不要分号&lt;/li&gt;
&lt;li&gt;Blend SrcAlpha OneMinusSrcAlpha 渲染透明物体&lt;/li&gt;
&lt;li&gt;o.Normal 为扰动法相&lt;/li&gt;
&lt;li&gt;Input
&lt;ul&gt;
&lt;li&gt;viewDir z 为深度&lt;/li&gt;
&lt;li&gt;uvXXX&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;clip(x) 当x&amp;lt;0时丢弃&lt;/li&gt;
&lt;li&gt;Cull off front back 双面渲染，正反面&lt;/li&gt;
&lt;li&gt;saturate 出于01之间&lt;/li&gt;
&lt;li&gt;frac 取小数部分&lt;/li&gt;
&lt;li&gt;CG std lib http://http.developer.nvidia.com/Cg/index_stdlib.html&lt;/li&gt;
&lt;li&gt;build-in struct http://docs.unity3d.com/Documentation/Components/SL-SurfaceShaders.html&lt;/li&gt;
&lt;li&gt;INTERNAL_DATA&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&quot;day10&quot;&gt;day10&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;rendering paths
&lt;ul&gt;
&lt;li&gt;forward&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;UsePath “Diffuse/FORWARD”&lt;/li&gt;
&lt;li&gt;Material.SetColor(“xxx”, color)&lt;/li&gt;
&lt;li&gt;appdata_base/tan
&lt;ul&gt;
&lt;li&gt;TANGENT 在法线贴图中的切向量&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;surface can’t in pass&lt;/li&gt;
&lt;li&gt;[ExecuteInEditMode]&lt;/li&gt;
&lt;li&gt;Cull ZWrite ZTest&lt;/li&gt;
&lt;li&gt;Blend 用来混合 pass
&lt;ul&gt;
&lt;li&gt;Blend x y = SrcColor * x + DstColor * y&lt;/li&gt;
&lt;li&gt;BlendOp Min | Max | Sub | RevSub&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;vertex shader 需要对uv赋值&lt;/li&gt;
&lt;li&gt;TextureName_ST TRANSFORM_TEX&lt;/li&gt;
&lt;li&gt;_SinTime&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&quot;day11&quot;&gt;day11&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;RenderTexture.active&lt;/li&gt;
&lt;li&gt;source.SetGlobalShaderProperty (“_RenderTex“);&lt;/li&gt;
&lt;li&gt;Graphics.Blit(source, dest, mat);&lt;/li&gt;
&lt;li&gt;DepthTextureMode _CameraDepthTexture&lt;/li&gt;
&lt;li&gt;ZTest Always Cull Off ZWrite Off&lt;/li&gt;
&lt;li&gt;&lt;span class=&quot;citation&quot; data-cites=&quot;script&quot;&gt;@script&lt;/span&gt; RequireComponent (Camera)&lt;/li&gt;
&lt;li&gt;island height map&lt;/li&gt;
&lt;li&gt;setrslt&lt;/li&gt;
&lt;li&gt;SkyBoxGenerator&lt;/li&gt;
&lt;li&gt;matcaps&lt;/li&gt;
&lt;li&gt;fake sss&lt;/li&gt;
&lt;li&gt;Renderer.sharedMaterial&lt;/li&gt;
&lt;li&gt;StaticBatchingUtility.Combine&lt;/li&gt;
&lt;li&gt;b.transform.parent = a.transform&lt;/li&gt;
&lt;li&gt;MeshCombineUtility&lt;/li&gt;
&lt;/ul&gt;
</description>
                <link>http://cjld.github.io/2014/02/04/unitynewbie</link>
                <guid>http://cjld.github.io/2014/02/04/unitynewbie</guid>
                <pubDate>2014-02-04T00:00:00+08:00</pubDate>
        </item>

        <item>
                <title>跨年折腾路由器</title>
                <description>&lt;p&gt;跨年折腾路由器到5点30，ld啊ld，再不复习你就要挂科了……&lt;/p&gt;
&lt;p&gt;回归正题，这次受许导推荐，可以在路由器上装一个 &lt;code&gt;OpenWrt&lt;/code&gt;， 为什么要装这个？ 因为 &lt;code&gt;OpenWrt&lt;/code&gt; 就是一个专门针对路由器的嵌入式 linux 操作系统，有了这玩意以后你想对路由器干什么就可以干什么了：做代理服务器、做FTP、做网页服务器等等…非常好玩~&lt;/p&gt;
&lt;p&gt;首先是准备工作：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;有一台支持刷 OpenWrt 的路由器&lt;/p&gt;
&lt;p&gt;我的路由器是 TL-MR11U V2， OpenWrt 上有对 V2 的支持，直接刷就行了&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;U盘&lt;/p&gt;
&lt;p&gt;这个要看你路由器内部存储空间有多大了，我的只有1M， 必须要用U盘扩容，当然前提是路由器有USB接口&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Telnet&lt;/p&gt;
&lt;p&gt;第一次要用 Telnet 连上路由器， win8 默认没有开启 Telnet 服务，得手动打开下&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;OpenSSH&lt;/p&gt;
&lt;p&gt;用来连SSH&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;WinSCP&lt;/p&gt;
&lt;p&gt;用来传文件，意外的好用&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;
&lt;h3 id=&quot;刷-openwrt&quot;&gt;刷 OpenWrt&lt;/h3&gt;
&lt;p&gt;参考自&lt;a href=&quot;http://see.sl088.com/wiki/MR11U_V2.0/%E5%8E%9F%E5%8E%82%E5%9B%BA%E4%BB%B6%E5%88%B7%E5%88%B0Openwrt&quot;&gt;MR11U V2.0/原厂固件刷到Openwrt&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;首先在 web 界面直接把下载的固件刷进去。&lt;/p&gt;
&lt;p&gt;然后接下来就是 console 连接了， 因为 TL-MR11U 默认只有1个口，wan/lan口通用，所以先得拿网线一端插电脑一端插路由器，具体参考&lt;a href=&quot;http://see.sl088.com/wiki/MR11U_V2.0/%E5%8E%9F%E5%8E%82%E5%9B%BA%E4%BB%B6%E5%88%B7%E5%88%B0Openwrt&quot;&gt;1&lt;/a&gt;&lt;/p&gt;
&lt;hr /&gt;
&lt;h3 id=&quot;连上网-以及-放出wifi&quot;&gt;连上网 以及 放出WiFi&lt;/h3&gt;
&lt;p&gt;这个地方折腾了挺久，主要是不知道配置文件怎么写，网上很多配置文件直接抄都不对。&lt;/p&gt;
&lt;p&gt;上网配置主要修改 &lt;code&gt;etc/config/network&lt;/code&gt;， WiFi配置主要修改 &lt;code&gt;etc/config/wireless&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;下面贴上 THU 的配置（固定IP）&lt;/p&gt;
&lt;h4 id=&quot;etcconfignetwork&quot;&gt;/etc/config/network&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;config interface &amp;#39;lan&amp;#39;
#   option ifname &amp;#39;eth0&amp;#39;
    option type &amp;#39;bridge&amp;#39;
    option proto &amp;#39;static&amp;#39;
    option ipaddr &amp;#39;192.168.1.1&amp;#39;
    option netmask &amp;#39;255.255.255.0&amp;#39;
    option ip6assign &amp;#39;60&amp;#39;

config interface &amp;#39;wan&amp;#39;
    option ifname &amp;#39;eth0&amp;#39;
    option proto &amp;#39;static&amp;#39;
    option ipaddr &amp;#39;59.66.**.**&amp;#39;
    option netmask &amp;#39;255.255.255.0&amp;#39;
    option gateway &amp;#39;59.66.**.1&amp;#39;
    option dns &amp;#39;166.111.8.28&amp;#39;&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&quot;etcconfigwireless&quot;&gt;/etc/config/wireless&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;config wifi-iface
    option device &amp;#39;radio0&amp;#39;
    option network &amp;#39;lan&amp;#39;
    option mode &amp;#39;ap&amp;#39;
    option ssid &amp;#39;ssidname&amp;#39;
    option encryption &amp;#39;psk2&amp;#39;
    option key &amp;#39;password&amp;#39;&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&quot;重启网络&quot;&gt;重启网络&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;/etc/init.d/network restart&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这样就能看见 WiFi 了&lt;/p&gt;
&lt;hr /&gt;
&lt;h3 id=&quot;u盘扩容&quot;&gt;U盘扩容&lt;/h3&gt;
&lt;p&gt;这一步应该现在做，第一次安装的时候直接装图形界面去了，导致空间不够大然后怒跪…&lt;/p&gt;
&lt;p&gt;U盘扩容网上似乎有很多方法，这篇文章感觉比较好弄：&lt;a href=&quot;http://blog.csdn.net/hexw7/article/details/9864617&quot;&gt;703n的OpenWrt配置二:U盘扩容&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;注意要先给U盘分好两个区，一个用来当swap，因为不知道怎么直接在 OpenWrt 里面分，跑到 linux 分好才弄过来的&lt;/p&gt;
&lt;hr /&gt;
&lt;h3 id=&quot;装上软件包&quot;&gt;装上软件包&lt;/h3&gt;
&lt;p&gt;现在空间这么大了，可以使劲装了吧。&lt;/p&gt;
&lt;p&gt;先 update&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;opkg update&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;装上图形界面&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;opkg install luci luci-i18n-chinese
/etc/init.d/uhttpd enable
/etc/init.d/uhttpd start&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这下在浏览器里输入 &lt;code&gt;192.168.1.1&lt;/code&gt; 就能进入图形界面了&lt;/p&gt;
&lt;hr /&gt;
&lt;h3 id=&quot;配置-ipv6&quot;&gt;配置 ipv6&lt;/h3&gt;
&lt;p&gt;首先得装上 ip 6in4 &lt;code&gt;opkg install ip 6in4&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;然后执行下面脚本&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;local_ip=59.66.**.**

ip tunnel add sit1 mode sit remote 166.111.21.1 local $local_ip
ifconfig sit1 up
ifconfig sit1 add 2402:f000:1:1501:200:5efe:$local_ip/64
ip route add ::/0 via 2402:f000:1:1501::1 metric 1&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;ipv6.tsinghua.edu.cn 上面的地址过时了，得改改地址&lt;/p&gt;
&lt;hr /&gt;
&lt;h3 id=&quot;运行-goagent&quot;&gt;运行 Goagent&lt;/h3&gt;
&lt;p&gt;跑 Goagent 和 linux 系统差不多，装上 python、openssl等等就可以直接跑了。&lt;/p&gt;
&lt;p&gt;为了让连上路由器的每一台机器都能用上goagent，得这么改改 &lt;code&gt;proxy.ini&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;[listen]
ip = 192.168.1.1
port = 8087
visible = 1
debuginfo = 0

...

profile = google_ipv6

...&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;让 goagent 静默的跑&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;python ~/goagent/local/proxy.py &amp;gt;/dev/null 2&amp;gt;&amp;amp;1 &amp;amp;&lt;/code&gt;&lt;/pre&gt;
&lt;hr /&gt;
&lt;h3 id=&quot;在公网放出加密代理&quot;&gt;在公网放出加密代理&lt;/h3&gt;
&lt;p&gt;许导告诉我可以用 &lt;code&gt;Shadowsocks&lt;/code&gt; 来在公网放出加密代理，有空再弄弄.&lt;/p&gt;
&lt;hr /&gt;
&lt;h3 id=&quot;参考文章&quot;&gt;参考文章&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://see.sl088.com/wiki/MR11U_V2.0/%E5%8E%9F%E5%8E%82%E5%9B%BA%E4%BB%B6%E5%88%B7%E5%88%B0Openwrt&quot;&gt;MR11U V2.0/原厂固件刷到Openwrt&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://blog.csdn.net/hexw7/article/details/9864617&quot;&gt;703n的OpenWrt配置二:U盘扩容&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://scola.github.io/deploy-goagent-on-openwrt-tplink-703n/&quot;&gt;在openwrt-tplink703n路由器上成功部署GoAgent&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;update&quot;&gt;Update&lt;/h3&gt;
&lt;p&gt;某次玩脱了，重置了路由器，结果软件包怎么都装不了， 发现官方源地址换了，详见&lt;a href=&quot;http://www.right.com.cn/forum/forum.php?mod=viewthread&amp;amp;action=printable&amp;amp;tid=104602&quot;&gt;http://www.right.com.cn/forum/forum.php?mod=viewthread&amp;amp;action=printable&amp;amp;tid=104602&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;同时还得刷一下固件&lt;/p&gt;
&lt;p&gt;在 &lt;code&gt;/etc/resolv.conf&lt;/code&gt; 中配置dns服务器&lt;/p&gt;
</description>
                <link>http://cjld.github.io/2014/01/01/routerfck</link>
                <guid>http://cjld.github.io/2014/01/01/routerfck</guid>
                <pubDate>2014-01-01T00:00:00+08:00</pubDate>
        </item>

        <item>
                <title>Blog 折腾</title>
                <description>&lt;p&gt;考试周不好好复习还在作死乱折腾……&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id=&quot;试一下公式&quot;&gt;试一下公式&lt;/h2&gt;
&lt;p&gt;&lt;span class=&quot;math&quot;&gt;\[ e^{i\pi} + 1 = 0 \]&lt;/span&gt;&lt;/p&gt;
&lt;h2 id=&quot;试一下-pandoc&quot;&gt;试一下 Pandoc&lt;/h2&gt;
&lt;h3 id=&quot;行区块&quot;&gt;行区块&lt;/h3&gt;
&lt;p&gt;行区块可以不吞行首空格。&lt;/p&gt;
&lt;p&gt;                  行区块行区块行区块行区块行区块行区块行区块行区块行区块行区块行区块行区块行区块行区块行区块行区块行区块行区块行区块行区块行区块行区块行区块行区块行区块行区块行区块行区块行区块行区块行区块行区块行区块行区块行区块行区块行区块行区块行区块行区块行区块行区块行区块行区块行区块行区块行区块行区块行区块行区块行区块行区块行区块行区块行区块行区块行区块行区块&lt;/p&gt;
&lt;h3 id=&quot;表格&quot;&gt;表格&lt;/h3&gt;
&lt;p&gt;折腾 pandoc 主要就为了这个表格&lt;/p&gt;
&lt;p&gt;山寨 IOS 扁平化大圆角风格&lt;/p&gt;
&lt;table&gt;
&lt;caption&gt;期末考试时间&lt;/caption&gt;
&lt;thead&gt;
&lt;tr class=&quot;header&quot;&gt;
&lt;th style=&quot;text-align: center;&quot;&gt;考试项目&lt;/th&gt;
&lt;th style=&quot;text-align: center;&quot;&gt;时间&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr class=&quot;odd&quot;&gt;
&lt;td style=&quot;text-align: center;&quot;&gt;复变函数&lt;/td&gt;
&lt;td style=&quot;text-align: center;&quot;&gt;1.8&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=&quot;even&quot;&gt;
&lt;td style=&quot;text-align: center;&quot;&gt;大物&lt;/td&gt;
&lt;td style=&quot;text-align: center;&quot;&gt;1.10&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=&quot;odd&quot;&gt;
&lt;td style=&quot;text-align: center;&quot;&gt;电子学基础&lt;/td&gt;
&lt;td style=&quot;text-align: center;&quot;&gt;1.16&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;table&gt;
&lt;caption&gt;Demonstration of simple table syntax.&lt;/caption&gt;
&lt;thead&gt;
&lt;tr class=&quot;header&quot;&gt;
&lt;th style=&quot;text-align: right;&quot;&gt;Right&lt;/th&gt;
&lt;th style=&quot;text-align: left;&quot;&gt;Left&lt;/th&gt;
&lt;th style=&quot;text-align: center;&quot;&gt;Center&lt;/th&gt;
&lt;th style=&quot;text-align: left;&quot;&gt;Default&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr class=&quot;odd&quot;&gt;
&lt;td style=&quot;text-align: right;&quot;&gt;12&lt;/td&gt;
&lt;td style=&quot;text-align: left;&quot;&gt;12&lt;/td&gt;
&lt;td style=&quot;text-align: center;&quot;&gt;12&lt;/td&gt;
&lt;td style=&quot;text-align: left;&quot;&gt;12&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=&quot;even&quot;&gt;
&lt;td style=&quot;text-align: right;&quot;&gt;123&lt;/td&gt;
&lt;td style=&quot;text-align: left;&quot;&gt;123&lt;/td&gt;
&lt;td style=&quot;text-align: center;&quot;&gt;123&lt;/td&gt;
&lt;td style=&quot;text-align: left;&quot;&gt;123&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=&quot;odd&quot;&gt;
&lt;td style=&quot;text-align: right;&quot;&gt;1&lt;/td&gt;
&lt;td style=&quot;text-align: left;&quot;&gt;1&lt;/td&gt;
&lt;td style=&quot;text-align: center;&quot;&gt;1&lt;/td&gt;
&lt;td style=&quot;text-align: left;&quot;&gt;1&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;table&gt;
&lt;tbody&gt;
&lt;tr class=&quot;odd&quot;&gt;
&lt;td style=&quot;text-align: right;&quot;&gt;12&lt;/td&gt;
&lt;td style=&quot;text-align: left;&quot;&gt;12&lt;/td&gt;
&lt;td style=&quot;text-align: center;&quot;&gt;12&lt;/td&gt;
&lt;td style=&quot;text-align: right;&quot;&gt;12&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=&quot;even&quot;&gt;
&lt;td style=&quot;text-align: right;&quot;&gt;123&lt;/td&gt;
&lt;td style=&quot;text-align: left;&quot;&gt;123&lt;/td&gt;
&lt;td style=&quot;text-align: center;&quot;&gt;123&lt;/td&gt;
&lt;td style=&quot;text-align: right;&quot;&gt;123&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=&quot;odd&quot;&gt;
&lt;td style=&quot;text-align: right;&quot;&gt;1&lt;/td&gt;
&lt;td style=&quot;text-align: left;&quot;&gt;1&lt;/td&gt;
&lt;td style=&quot;text-align: center;&quot;&gt;1&lt;/td&gt;
&lt;td style=&quot;text-align: right;&quot;&gt;1&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;table&gt;
&lt;caption&gt;Here’s the caption. It, too, may span multiple lines.&lt;/caption&gt;
&lt;col style=&quot;width: 16%&quot; /&gt;&lt;col style=&quot;width: 11%&quot; /&gt;&lt;col style=&quot;width: 22%&quot; /&gt;&lt;col style=&quot;width: 34%&quot; /&gt;&lt;thead&gt;
&lt;tr class=&quot;header&quot;&gt;
&lt;th style=&quot;text-align: center;&quot;&gt;Centered Header&lt;/th&gt;
&lt;th style=&quot;text-align: left;&quot;&gt;Default Aligned&lt;/th&gt;
&lt;th style=&quot;text-align: right;&quot;&gt;Right Aligned&lt;/th&gt;
&lt;th style=&quot;text-align: left;&quot;&gt;Left Aligned&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr class=&quot;odd&quot;&gt;
&lt;td style=&quot;text-align: center;&quot;&gt;First&lt;/td&gt;
&lt;td style=&quot;text-align: left;&quot;&gt;row&lt;/td&gt;
&lt;td style=&quot;text-align: right;&quot;&gt;12.0&lt;/td&gt;
&lt;td style=&quot;text-align: left;&quot;&gt;Example of a row that spans multiple lines.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=&quot;even&quot;&gt;
&lt;td style=&quot;text-align: center;&quot;&gt;Second&lt;/td&gt;
&lt;td style=&quot;text-align: left;&quot;&gt;row&lt;/td&gt;
&lt;td style=&quot;text-align: right;&quot;&gt;5.0&lt;/td&gt;
&lt;td style=&quot;text-align: left;&quot;&gt;Here’s another one. Note the blank line between rows.&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;table&gt;
&lt;caption&gt;Here’s a multiline table without headers.&lt;/caption&gt;
&lt;col style=&quot;width: 16%&quot; /&gt;&lt;col style=&quot;width: 11%&quot; /&gt;&lt;col style=&quot;width: 22%&quot; /&gt;&lt;col style=&quot;width: 34%&quot; /&gt;&lt;tbody&gt;
&lt;tr class=&quot;odd&quot;&gt;
&lt;td style=&quot;text-align: center;&quot;&gt;First&lt;/td&gt;
&lt;td style=&quot;text-align: left;&quot;&gt;row&lt;/td&gt;
&lt;td style=&quot;text-align: right;&quot;&gt;12.0&lt;/td&gt;
&lt;td style=&quot;text-align: left;&quot;&gt;Example of a row that spans multiple lines.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=&quot;even&quot;&gt;
&lt;td style=&quot;text-align: center;&quot;&gt;Second&lt;/td&gt;
&lt;td style=&quot;text-align: left;&quot;&gt;row&lt;/td&gt;
&lt;td style=&quot;text-align: right;&quot;&gt;5.0&lt;/td&gt;
&lt;td style=&quot;text-align: left;&quot;&gt;Here’s another one. Note the blank line between rows.&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;table&gt;
&lt;caption&gt;Sample grid table.&lt;/caption&gt;
&lt;thead&gt;
&lt;tr class=&quot;header&quot;&gt;
&lt;th style=&quot;text-align: right;&quot;&gt;Right&lt;/th&gt;
&lt;th style=&quot;text-align: left;&quot;&gt;Left&lt;/th&gt;
&lt;th style=&quot;text-align: left;&quot;&gt;Default&lt;/th&gt;
&lt;th style=&quot;text-align: center;&quot;&gt;Center&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr class=&quot;odd&quot;&gt;
&lt;td style=&quot;text-align: right;&quot;&gt;12&lt;/td&gt;
&lt;td style=&quot;text-align: left;&quot;&gt;12&lt;/td&gt;
&lt;td style=&quot;text-align: left;&quot;&gt;12&lt;/td&gt;
&lt;td style=&quot;text-align: center;&quot;&gt;12&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=&quot;even&quot;&gt;
&lt;td style=&quot;text-align: right;&quot;&gt;123&lt;/td&gt;
&lt;td style=&quot;text-align: left;&quot;&gt;123&lt;/td&gt;
&lt;td style=&quot;text-align: left;&quot;&gt;123&lt;/td&gt;
&lt;td style=&quot;text-align: center;&quot;&gt;123&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=&quot;odd&quot;&gt;
&lt;td style=&quot;text-align: right;&quot;&gt;11111111111111111111111111111&lt;/td&gt;
&lt;td style=&quot;text-align: left;&quot;&gt;1&lt;/td&gt;
&lt;td style=&quot;text-align: left;&quot;&gt;1&lt;/td&gt;
&lt;td style=&quot;text-align: center;&quot;&gt;1&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;table&gt;
&lt;caption&gt;Demonstration of simple table syntax.&lt;/caption&gt;
&lt;thead&gt;
&lt;tr class=&quot;header&quot;&gt;
&lt;th style=&quot;text-align: right;&quot;&gt;fruit&lt;/th&gt;
&lt;th style=&quot;text-align: right;&quot;&gt;price&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr class=&quot;odd&quot;&gt;
&lt;td style=&quot;text-align: right;&quot;&gt;apple&lt;/td&gt;
&lt;td style=&quot;text-align: right;&quot;&gt;2.05&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=&quot;even&quot;&gt;
&lt;td style=&quot;text-align: right;&quot;&gt;pear&lt;/td&gt;
&lt;td style=&quot;text-align: right;&quot;&gt;1.37&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=&quot;odd&quot;&gt;
&lt;td style=&quot;text-align: right;&quot;&gt;orange&lt;/td&gt;
&lt;td style=&quot;text-align: right;&quot;&gt;3.09&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2 id=&quot;js-写了个目录&quot;&gt;js 写了个目录&lt;/h2&gt;
&lt;p&gt;看起来不错，自动抓文中的 h 标签，还有随滚动固定 .&lt;/p&gt;
</description>
                <link>http://cjld.github.io/2013/12/30/pandoctest</link>
                <guid>http://cjld.github.io/2013/12/30/pandoctest</guid>
                <pubDate>2013-12-30T00:00:00+08:00</pubDate>
        </item>

        <item>
                <title>图形学大作业文档</title>
                <description>&lt;p&gt;图形学大作业奋战了将近一个月，算是告一段落了，虽然还有很多想写的特性，但是落下了一堆功课得赶紧补了。&lt;/p&gt;
&lt;p&gt;参考了不少文章，最后效果还凑活，没有网上一些图片精致，从zsyzgu同学翻译的文章&lt;a href=&quot;http://hi.baidu.com/zsyzgu/archive/tag/%E5%85%89%E7%BA%BF%E8%BF%BD%E8%B8%AA&quot;&gt;4&lt;/a&gt;那参考了不少，这位同学今年参加了智能体，很是欣慰~&lt;/p&gt;
&lt;p&gt;下面是大作业的文档，放上来凑数&lt;/p&gt;
&lt;h2 id=&quot;基本信息&quot;&gt;1. 基本信息&lt;/h2&gt;
&lt;h3 id=&quot;作业内容&quot;&gt;1.1. 作业内容&lt;/h3&gt;
&lt;p&gt;实现光线跟踪以及网格简化。&lt;/p&gt;
&lt;h3 id=&quot;测试设备&quot;&gt;1.2. 测试设备&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;系统 : Windows 8&lt;/li&gt;
&lt;li&gt;CPU : I5-3230M 2.60GHz&lt;/li&gt;
&lt;li&gt;GPU : GT 750M&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;实现内容及特性&quot;&gt;1.3. 实现内容及特性&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;边压缩的网格简化，下图从左到右依次为 100、300、500、700、900个三角形&lt;/p&gt;
&lt;figure&gt;
&lt;img src=&quot;../../../../img/cghwimg/1.png&quot; /&gt;
&lt;/figure&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;支持 .obj 格式以及 .mtl 材质格式读入， 支持 UV 贴图， 支持法相平滑插值和位置插值，下图为对比效果图。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;../../../../img/cghwimg/2.png&quot; /&gt; &lt;img src=&quot;../../../../img/cghwimg/3.png&quot; /&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;SAH-KDTree 加速&lt;/p&gt;
&lt;p&gt;图中为968个三角形的模型，关闭阴影和抗锯齿，单线程耗时90ms，多线程耗时 40ms.&lt;/p&gt;
&lt;figure&gt;
&lt;img src=&quot;../../../../img/cghwimg/4.png&quot; /&gt;
&lt;/figure&gt;
&lt;p&gt;KdTree 网格划分情况，绿色为叶节点，红色为中间节点。&lt;/p&gt;
&lt;figure&gt;
&lt;img src=&quot;../../../../img/cghwimg/5.png&quot; /&gt;
&lt;/figure&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;OpenCL 显卡加速，KDTree遍历代码以及RayTrace递归过程 改非递归重写, 非递归KDTree部分参考自论文&lt;a href=&quot;http://www.mpi-inf.mpg.de/~guenther/StacklessGPURT/&quot;&gt;3&lt;/a&gt;。 因为从CPU传参数到GPU需要一定时间，所以使用较为复杂的场景，并且开启阴影和三个光源，效果如下图：&lt;/p&gt;
&lt;figure&gt;
&lt;img src=&quot;../../../../img/cghwimg/6.png&quot; /&gt;
&lt;/figure&gt;
&lt;p&gt;其中 CPU 单线程运算耗时5970ms， 多线程耗时为2698ms，OpenCL GPU耗时830ms&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;快速抗锯齿&lt;/p&gt;
&lt;p&gt;下左图为未抗锯齿抗锯齿，右图为抗锯齿&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;../../../../img/cghwimg/7.png&quot; /&gt; &lt;img src=&quot;../../../../img/cghwimg/8.png&quot; /&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;软阴影以及BRDF&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;../../../../img/cghwimg/9.png&quot; /&gt; &lt;img src=&quot;../../../../img/cghwimg/10.png&quot; /&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;红蓝3D&lt;/p&gt;
&lt;figure&gt;
&lt;img src=&quot;../../../../img/cghwimg/11.png&quot; /&gt;
&lt;/figure&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;实现原理&quot;&gt;2. 实现原理&lt;/h2&gt;
&lt;h3 id=&quot;网格简化&quot;&gt;2.1. 网格简化&lt;/h3&gt;
&lt;p&gt;已有一个三角网格，每次选一条最短的边然后将这条边所连的两个点合并，并删除重边。&lt;/p&gt;
&lt;p&gt;两个点合并以后产生一个新的点，这个点由这两个点的坐标以及这两个点的法向量二次插值计算得来，插值方法如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Xa Xb : a, b 的坐标
Fa Fb : a, b 的点法向量，由这个点附近的面的法向量插值得来
Normal(x) : 将 x 归一化
X = (a + b)/2 + Normal(Fa + Fb) * dot((Xa - Xb), Fa - Fb) / 4&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这样可以得到 C1 连续的顶点，如图所示&lt;/p&gt;
&lt;figure&gt;
&lt;img src=&quot;../../../../img/cghwimg/12.png&quot; /&gt;
&lt;/figure&gt;
&lt;h3 id=&quot;光线跟踪&quot;&gt;2.2. 光线跟踪&lt;/h3&gt;
&lt;h4 id=&quot;sah-kdtree&quot;&gt;2.2.1. SAH-KDTree&lt;/h4&gt;
&lt;p&gt;和普通 KDTree 不一样的是， SAH-KDTree 通过一个函数加权计算划分点。 具体参考论文&lt;a href=&quot;http://www.eng.utah.edu/~cs6965/papers/kdtree.pdf&quot;&gt;1&lt;/a&gt;.&lt;/p&gt;
&lt;h4 id=&quot;软阴影&quot;&gt;2.2.2. 软阴影&lt;/h4&gt;
&lt;p&gt;自然生活中，阴影的边缘多半是模糊的，这是因为光源并非点光源而是面光源，那么如何计算面光源，解析计算难度很大，有一个粗暴的方法是在这个面光源上随机取一个点， 然后把它当做点光源，这个方法显然太粗暴，于是乎可以将这个面划分成更多小面，比如4*4个小面，然后每个小面单独做在加权起来，如下图所示， 参考自网站&lt;a href=&quot;http://www.flipcode.com/archives/Raytracing_Topics_Techniques-Part_5_Soft_Shadows.shtml&quot;&gt;2&lt;/a&gt;。&lt;/p&gt;
&lt;figure&gt;
&lt;img src=&quot;../../../../img/cghwimg/13.png&quot; /&gt;
&lt;/figure&gt;
&lt;h4 id=&quot;蒙特卡洛光线跟踪&quot;&gt;2.2.3. 蒙特卡洛光线跟踪&lt;/h4&gt;
&lt;p&gt;蒙特卡洛光线跟踪可以对一些BRDF模型进行计算, 其思想和生成软阴影的方法有些类似， 参考自网站&lt;a href=&quot;http://www.flipcode.com/archives/Raytracing_Topics_Techniques-Part_5_Soft_Shadows.shtml&quot;&gt;2&lt;/a&gt;。&lt;/p&gt;
&lt;h4 id=&quot;红蓝3d&quot;&gt;2.2.4. 红蓝3D&lt;/h4&gt;
&lt;p&gt;这个挺简单的，就是在两只不同的眼睛生成两张不同的图片，然后在合并起来。 合并算法就是对于一个像素，红色分量取左眼的图片，蓝绿色色分量取右眼的图片。&lt;/p&gt;
&lt;h4 id=&quot;快速抗锯齿&quot;&gt;2.2.5. 快速抗锯齿&lt;/h4&gt;
&lt;p&gt;对于一张锯齿严重的图，抗锯齿是必须的，为什么会有锯齿的出现， 这是因为每个像素发射一条射线不足以描述这一个像素的颜色，为了采样这个像素的颜色，我们可以多发射几条射线。&lt;/p&gt;
&lt;p&gt;但是对于一张图，并不是所有像素都有重新采样的需求，比如我们可以对图像的边缘进行采样，有方法是，如果这个像素和附近的像素打到了不同的三角形上，那么对这个点进行采样，参考自网站&lt;a href=&quot;http://www.flipcode.com/archives/Raytracing_Topics_Techniques-Part_5_Soft_Shadows.shtml&quot;&gt;2&lt;/a&gt;， 如图：&lt;/p&gt;
&lt;figure&gt;
&lt;img src=&quot;../../../../img/cghwimg/14.png&quot; /&gt;
&lt;/figure&gt;
&lt;p&gt;对于一些特别精细的模型这个采样方法可能还不够高效，我们再计算下这个图像的梯度：&lt;/p&gt;
&lt;figure&gt;
&lt;img src=&quot;../../../../img/cghwimg/15.png&quot; /&gt;
&lt;/figure&gt;
&lt;p&gt;然后同时满足第一个条件和梯度大于阈值时才对这个点进行采样，如下图：&lt;/p&gt;
&lt;figure&gt;
&lt;img src=&quot;../../../../img/cghwimg/16.png&quot; /&gt;
&lt;/figure&gt;
&lt;h2 id=&quot;实现过程&quot;&gt;3. 实现过程&lt;/h2&gt;
&lt;h3 id=&quot;section&quot;&gt;2013.12.4&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;三角形求交，使用纯色进行着色&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;section-1&quot;&gt;2013.12.5&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Lambert着色，phong着色&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;section-2&quot;&gt;2013.12.6&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;使用极坐标分段三角片模拟球&lt;/li&gt;
&lt;li&gt;插值法向量，对模型做平滑处理平滑&lt;/li&gt;
&lt;li&gt;阴影的计算&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;section-3&quot;&gt;2013.12.7&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;可读取 obj 文件进行渲染&lt;/li&gt;
&lt;li&gt;代码重构&lt;/li&gt;
&lt;li&gt;实现反射与折射&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;section-4&quot;&gt;2013.12.8&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;实现 sah-kdtree 建树&lt;/li&gt;
&lt;li&gt;kdtree 线框图用于对kdtree进行分析&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;section-5&quot;&gt;2013.12.10&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;实现 kdtree 加速光线跟踪&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;section-6&quot;&gt;2013.12.13&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;CPU 多线程实现&lt;/li&gt;
&lt;li&gt;实现快速抗锯齿&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;section-7&quot;&gt;2013.12.14&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;支持 obj 以及 mtl 材质文件&lt;/li&gt;
&lt;li&gt;支持阴影色，实现“假”焦散效果 &lt;img src=&quot;../../../../img/cghwimg/17.png&quot; /&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;section-8&quot;&gt;2013.12.15&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;支持了纹理，支持 UV 贴图&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;section-9&quot;&gt;2013.12.20&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;实现了非递归 kdtree 的遍历&lt;/li&gt;
&lt;li&gt;通过位置插值来计算更加精确的阴影&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;section-10&quot;&gt;2013.12.21&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;实现 OpenCL 的移植， 比CPU多线程有5倍的提速&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;section-11&quot;&gt;2013.12.22&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;实现显卡抗锯齿&lt;/li&gt;
&lt;li&gt;光源衰减，让光源按照距离的平方项的倒数衰减&lt;/li&gt;
&lt;li&gt;啤酒瓶定理和菲涅尔项更好的渲染折射以及反射&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;section-12&quot;&gt;2013.12.23&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;实现面光源，软阴影&lt;/li&gt;
&lt;li&gt;蒙特卡洛光线跟踪计算BRDF&lt;/li&gt;
&lt;li&gt;循环队列广搜光线跟踪&lt;/li&gt;
&lt;li&gt;红蓝3D&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;section-13&quot;&gt;2013.12.25&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;网格简化&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;参考文献&quot;&gt;4. 参考文献&lt;/h2&gt;
&lt;p&gt;以下链接对我帮助很大，特此感谢~&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://www.eng.utah.edu/~cs6965/papers/kdtree.pdf&quot;&gt;[1] On building fast kd-Trees for Ray Tracing, and on doing that in O(N log N)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www.flipcode.com/archives/Raytracing_Topics_Techniques-Part_5_Soft_Shadows.shtml&quot;&gt;[2] Raytracing Topics &amp;amp; Techniques - Part 5: Soft Shadows&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www.mpi-inf.mpg.de/~guenther/StacklessGPURT/&quot;&gt;[3] Stackless KD-Tree Traversal for High Performance GPU Ray Tracing&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://hi.baidu.com/zsyzgu/archive/tag/%E5%85%89%E7%BA%BF%E8%BF%BD%E8%B8%AA&quot;&gt;zsyzgu同学翻译的[1]&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;几个学长的光线追踪
&lt;ul&gt;
&lt;li&gt;贾开学长的报告&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www.zxytim.com/%E5%85%89%E7%BA%BF%E8%B7%9F%E8%B8%AA%E5%BC%95%E6%93%8E-maskray-%E7%AC%94%E8%AE%B0/&quot;&gt;http://www.zxytim.com/%E5%85%89%E7%BA%BF%E8%B7%9F%E8%B8%AA%E5%BC%95%E6%93%8E-maskray-%E7%AC%94%E8%AE%B0/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www.ppwwyyxx.com/2013/More-On-Ray-Tracing/&quot;&gt;http://www.ppwwyyxx.com/2013/More-On-Ray-Tracing/&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
                <link>http://cjld.github.io/2013/12/25/cghwreport</link>
                <guid>http://cjld.github.io/2013/12/25/cghwreport</guid>
                <pubDate>2013-12-25T00:00:00+08:00</pubDate>
        </item>

        <item>
                <title>若干丧心病狂的平衡树</title>
                <description>&lt;p&gt;最近翻 paper，偶然看到了 O(log log N) 的堆，有些兴趣于是乎研究起来，依稀记得 fhq 在冬令营有讲过， 但是由于当时开小差所以没听懂，不过事后翻了翻当时的 ppt 也没太看懂。&lt;/p&gt;
&lt;p&gt;基于比较的排序已经是被证明复杂度不低于 O(NlogN) ，因此，基于比较的堆也不可能做到均摊 logN ，所以这些堆都有它的特殊性， 就是权值范围固定，比如权值范围为 D，则复杂度为 O(log log D)，当然，后面提到的这两种数据结构都不仅仅是一个堆，他们还可以找 lower_bound，复杂度同样是 O(loglogN)。&lt;/p&gt;
&lt;p&gt;Google 了一番，首先找到了这么一篇论文 &lt;code&gt;A Priority Queue in Which Initialization and Queue Operations Take O(loglogD) Time&lt;/code&gt;， 大概的思路是在在二叉树上二分，当然，这棵二叉树是静态的，底部有 2^n 个节点，一共 n+1 层，看了许久还拉上 lyp 看才差不多知道是个怎么回事， 但是对于实现还是一无所知……遂放弃这种方法……&lt;/p&gt;
&lt;p&gt;之后通过各种 Google，又找到这么一种数据结构，名曰 &lt;code&gt;Van Emde Boas trees&lt;/code&gt;，有一篇中文 Blog 讲的很好，&lt;a href=&quot;http://www.roading.org/algorithm/introductiontoalgorithm/Van_Emde_Boas_trees.html&quot;&gt;传送门&lt;/a&gt;，文中说算导里有介绍这个数据结构， 为啥我的算导上没有…&lt;/p&gt;
&lt;p&gt;简单的来说就是这样一个数据结构，假设一个大小为 N 的 veb树，那么他会有 sqrt(N) 个分支，每个分支都是一颗 veb树， 而为了维护这 sqrt(N) 个分支，专门在额外用一颗 veb树（假设命名为 summary ）来管理这 sqrt(N) 个分支。&lt;/p&gt;
&lt;p&gt;当然这么做还不够，一次插入岂不是既要在 summary 中插入又要在子树中插入，这样两次插入造成复杂度退化为 O(logN)，于是乎通过维护一个类似于 lazy 标记的最小值就可以做到每次只会产生一次新的递归调用，因为每次树的规模都是直接开根号，所以复杂度为 O(loglogN)。&lt;/p&gt;
&lt;p&gt;还算是个比较优美的算法，而且常数似乎不大，&lt;a href=&quot;https://github.com/cjld/DLIB/blob/master/c%2B%2B/include/_vebtree/vebtree.cpp&quot;&gt;怒实现了一发&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;但是不幸的是，做了下测试，这货和 treap 差不多…&lt;/p&gt;
</description>
                <link>http://cjld.github.io/2013/11/26/crazyheap</link>
                <guid>http://cjld.github.io/2013/11/26/crazyheap</guid>
                <pubDate>2013-11-26T00:00:00+08:00</pubDate>
        </item>

        <item>
                <title>QtOpenGL高版本api使用</title>
                <description>&lt;p&gt;要在 Qt 中使用 OpenGL，QGLWidget是一个很不错的选择，只需重载几个函数就好了。&lt;/p&gt;
&lt;p&gt;但是在 QGLWidget 中，只有非常少数的 OpenGL 函数，查阅文档，在 &lt;code&gt;QGLFunctions&lt;/code&gt; 类里有 OpenGL2.0/ES 的基本函数，没有更高版本的函数。&lt;/p&gt;
&lt;p&gt;QGLFunctions 的使用方法比较简单，在构造函数中传入 QGLContext 就好了。&lt;/p&gt;
&lt;p&gt;苦苦 Google 了一番，Qt把函数封装到一些奇怪的类里，如 QOpenGLFunctions_1_0, QOpenGLFunctions_1_1, QOpenGLFunctions_1_2, QOpenGLFunctions_1_3, QOpenGLFunctions_1_4, QOpenGLFunctions_1_5, QOpenGLFunctions_2_0, QOpenGLFunctions_2_1, QOpenGLFunctions_3_0 …&lt;/p&gt;
&lt;p&gt;非常奇怪为什么 Qt 需要做这些奇怪的封装，似乎是为了跨平台的需求，那既然是在 pc 上，如何使用高版本的 API ？&lt;/p&gt;
&lt;p&gt;&lt;code&gt;QOpenGLFunctions_X_X&lt;/code&gt;的使用方法和&lt;code&gt;QGLFunctions&lt;/code&gt;的使用方法不太一样，仍然需要继承自&lt;code&gt;QOpenGLFunctions_X_X&lt;/code&gt;，当然，直接声明也可以，如我实现的 QGLCL的renderbuffer：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;struct DCLRenderBufferGL : public DCLBuffer, public QOpenGLFunctions_3_0 {
    DCLRenderBufferGL() {
        initializeOpenGLFunctions();
    }
}；&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;需要额外调用 &lt;code&gt;initializeOpenGLFunctions()&lt;/code&gt; 来初始化函数，但是使用的时候我却出现了 bug，&lt;code&gt;initializeOpenGLFunctions()&lt;/code&gt;返回 false，然后函数使用返回段错误。&lt;/p&gt;
&lt;p&gt;几番折腾以后找到了问题所在 ———— OpenGL上下文版本设置有问题，需要加入以下代码：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;QGLFormat glf = QGLFormat::defaultFormat();
glf.setVersion(3,0);
QGLFormat::setDefaultFormat(glf); &lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;注意，这个地方的 setVersion 必须不大不小刚刚好……&lt;/p&gt;
&lt;p&gt;折腾这个的目的是，之前 OpenCL/OpenGL共享 中提到的 FBO，在 &lt;a href=&quot;http://www.opengpu.org/&quot;&gt;OpenGPU&lt;/a&gt; 论坛上&lt;a href=&quot;http://www.opengpu.org/forum.php?mod=viewthread&amp;amp;tid=15965&quot;&gt;提问&lt;/a&gt;以后得到了大神的回复，使用 &lt;code&gt;glBlitFramebuffer&lt;/code&gt;，这个函数是 OpenGL3.0的标准。&lt;/p&gt;
</description>
                <link>http://cjld.github.io/2013/10/25/qtopenglhighversion</link>
                <guid>http://cjld.github.io/2013/10/25/qtopenglhighversion</guid>
                <pubDate>2013-10-25T00:00:00+08:00</pubDate>
        </item>

        <item>
                <title>Qt重定义链接错误</title>
                <description>&lt;p&gt;当你&lt;code&gt;#include&lt;/code&gt;的头文件包含了一些全局函数或者变量的定义，并且这个头文件被多个 cpp 文件引用时，Qt一定会返回重定义链接错误，即使你的头文件里有&lt;code&gt;#ifndef&lt;/code&gt;这样的代码。&lt;/p&gt;
&lt;p&gt;这是为什么呢？仔细观察&lt;code&gt;qmake&lt;/code&gt;生成的&lt;code&gt;makefile&lt;/code&gt;文件，可以发现他做的事情是把不同的 &lt;code&gt;*.cpp&lt;/code&gt; 文件编译成 &lt;code&gt;*.o&lt;/code&gt; ，然后再一口气把所有编译成 &lt;code&gt;.exe&lt;/code&gt;，问题就出在这里，不同的 &lt;code&gt;*.o&lt;/code&gt; 文件因为 &lt;code&gt;#include&lt;/code&gt; 了这个头文件，而都包含了这些全局函数变量的定义，于是乎就出错了。&lt;/p&gt;
&lt;p&gt;要解决全局变量的问题，加个&lt;code&gt;extern&lt;/code&gt;就好了，表示这是个全局变量的声明而不是定义。&lt;/p&gt;
&lt;p&gt;要解决全局函数的问题，一个方法是把函数写到类里面就可以编译过了，注意下面两种写法：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;struct A {
    void haha() {};
};

struct B {
    void haha();
}

void B::haha() {}&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;A 是可以编译通过的，但是 B 却不行，对编译原理不是很了解，可能是因为&lt;code&gt;void B::haha() {}&lt;/code&gt;被当做一个全局函数定义。&lt;/p&gt;
&lt;p&gt;于是为了让 B 编译过，把函数放到里面就好了。&lt;/p&gt;
&lt;p&gt;但是碰到某些情况是必须写在外部的，比如类的相互引用：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;struct A;
struct B;

struct A {
    B *b;
    void haha();
}

struct B {
    A *a;
    void haha();
}

void A::haha() {b=b-&amp;gt;a-&amp;gt;b;}
void B::haha() {a=a-&amp;gt;b-&amp;gt;a;}&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;解决办法是把定义分开写到 cpp 里。&lt;/p&gt;
&lt;p&gt;当这个头文件要作为一个库的时候，你就需要将 cpp 编译成 lib，然后链接，但是有时自己写的库不想编译成lib，因为不方便管理，于是乎有一个蛋疼的方法是，吧cpp文件也放到 include 目录里，然后让你的某一个文件 &lt;code&gt;#include&lt;/code&gt; 你的这个 cpp 就好了，这样函数就只会定义一次。&lt;/p&gt;
</description>
                <link>http://cjld.github.io/2013/10/11/qtlinkerror</link>
                <guid>http://cjld.github.io/2013/10/11/qtlinkerror</guid>
                <pubDate>2013-10-11T00:00:00+08:00</pubDate>
        </item>

        <item>
                <title>OpenCL与OpenGL共享折腾二三事</title>
                <description>&lt;p&gt;为了让图形课的作业可以用 OpenCL 做实时绘制，于是乎开始折腾如何让 OpenCL 中的图片可以高效的渲染到屏幕上，饶了一大圈学了不少 OpenGL 的用法，最后最好的解决方案也只能是共享&lt;code&gt;texture/image&lt;/code&gt;，然后在 OpenGL中在绘制一遍。&lt;/p&gt;
&lt;hr /&gt;
&lt;h3 id=&quot;pbo&quot;&gt;PBO&lt;/h3&gt;
&lt;p&gt;首先是尝试使用 PBO(Pixel Buffer Object) 来和OpenCL交互，使用起来非常方便，和之前文章提到的 VBO 用法是一样的。&lt;/p&gt;
&lt;p&gt;创建了 PBO 以后，直接用以下代码就可以绘制到&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;//绑定pbo
glBindBufferARB(GL_PIXEL_UNPACK_BUFFER_ARB, pboIds[index]);
//绘制，因为我们已经 bind pbo 了，所以 data 参数设置为 0， opengl就会从pbo中读数据
void glDrawPixels(width, height, format, type, 0);&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;看 OpenGL 的介绍：“glDrawPixels — write a block of pixels to the frame buffer”，应该很快吧，都直接写到帧缓存里了。&lt;/p&gt;
&lt;p&gt;但是实际结果是比较慢的，800*600 需要花将近4ms，fps300多，1920*1080就要接近10ms，自己直接把数据从 OpenCL 拷到 CPU 再拷到 OpenGL，发现速度是一样的。&lt;/p&gt;
&lt;p&gt;事后认真看了下 PBO 的&lt;a href=&quot;http://www.songho.ca/opengl/gl_pbo.html&quot;&gt;介绍&lt;/a&gt;，发现 PBO 分两种：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;GL_PIXEL_UNPACK_BUFFER_ARB&lt;/code&gt; 用于从CPU传送数据给GPU&lt;/li&gt;
&lt;li&gt;&lt;code&gt;GL_PIXEL_PACK_BUFFER_ARB&lt;/code&gt; 用于从GPU传送数据给CPU&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;我一开始就理解错了，这玩意本来就只是用来和 CPU 传送数据的，于是这个方法失败&lt;/p&gt;
&lt;hr /&gt;
&lt;h3 id=&quot;fbo&quot;&gt;FBO&lt;/h3&gt;
&lt;p&gt;于是乎开始折腾 FBO, 网上找到这么个 &lt;a href=&quot;http://sa09.idav.ucdavis.edu/docs/SA09_GL_interop.pdf&quot;&gt;PPT&lt;/a&gt; 讲的比较清楚，这个 PPT 中实现的内容大概是用 OpenGL 渲染出一个图片以后，传给 OpenCL 做一次高斯模糊再显示出来，用法如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// 创建并绑定FBO
glGenFramebuffersEXT(1, &amp;amp;fbo);
glBindFramebufferEXT(GL_FRAMEBUFFER_EXT, fbo);
// 创建一个RenderBuffer
glGenRenderbuffersEXT(1, &amp;amp;rb_color);
glBindRenderbufferEXT(GL_RENDERBUFFER_EXT, rb_color);
glRenderbufferStorageEXT(GL_RENDERBUFFER_EXT, GL_RGBA8, width, height);
// 吧rbo挂载到FBO的颜色缓冲区
glFramebufferRenderbufferEXT(GL_FRAMEBUFFER_EXT, GL_COLOR_ATTACHMENT0_EXT, GL_RENDERBUFFER_EXT, rb_color);

// 从gl创建cl buffer
cl_mem cl_scene; 
cl_scene = clCreateFromGLRenderbuffer(cxGPUContext, CL_MEM_READ_ONLY, rb_color, 0);&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;用法也比较简单，在 OpenCL 可以直接使用 &lt;code&gt;image2d_t&lt;/code&gt; 对象接触，但是问题又来了，bind frame buffer以后屏幕就什么也显示不出来了，从&lt;a href=&quot;http://blog.csdn.net/xiajun07061225/article/details/7283929&quot;&gt;文章&lt;/a&gt;中仔细阅读FBO以后大概理解了FBO的工作原理。&lt;/p&gt;
&lt;p&gt;FBO（FrameBufferObject），被用来让用户创建FrameBuffer，一开始我们的图像系统为我们已经创建好了一个FrameBuffer，被称之为&lt;a href=&quot;http://www.opengl.org/wiki/Default_Framebuffer&quot;&gt;Default Framebuffer&lt;/a&gt;，它由若干个&lt;code&gt;ColorBuffer&lt;/code&gt;，一个&lt;code&gt;DepthBuffer&lt;/code&gt;，一个&lt;code&gt;StencilBuffer&lt;/code&gt;构成，而 FBO 允许用户自己通过创建 &lt;code&gt;RenderBuffer&lt;/code&gt; 和 &lt;code&gt;Texture&lt;/code&gt; 来挂载管理这些不同的 buffer，他的用途多半用在渲染到 texture。&lt;/p&gt;
&lt;p&gt;问题就出在，如果你bind了自己创建的frameBuffer，那么 OpenGL 就会吧图像渲染到你的 frameBuffer 里去，而 Default FrameBuffer 里还是空的，于是屏幕就黑了。&lt;/p&gt;
&lt;p&gt;由于对 OpenGL 了解不深刻，也不清楚怎么直接管理 Default FrameBuffer ，尝试了下直接 bind renderbuffer 到 Default FrameBuffer 上去返回&lt;code&gt;无效操作&lt;/code&gt;，于是乎这个方法也作废了…&lt;/p&gt;
&lt;p&gt;不过总的来说 FBO 还是很有用的。&lt;/p&gt;
&lt;h3 id=&quot;update&quot;&gt;update&lt;/h3&gt;
&lt;p&gt;在 &lt;a href=&quot;http://www.opengpu.org/&quot;&gt;OpenGPU&lt;/a&gt; 论坛上&lt;a href=&quot;http://www.opengpu.org/forum.php?mod=viewthread&amp;amp;tid=15965&quot;&gt;提问&lt;/a&gt;以后得到了大神的回复，使用 &lt;code&gt;glBlitFramebuffer&lt;/code&gt;，这个函数是 OpenGL3.0的标准。&lt;/p&gt;
&lt;p&gt;尝试了一番以后发现速度和第三个方法差不多。&lt;/p&gt;
&lt;hr /&gt;
&lt;h3 id=&quot;textureimage&quot;&gt;Texture/image&lt;/h3&gt;
&lt;p&gt;最后的方法还是回归到直接让 OpenGL 和 OpenCL 共享 Texture，然后用 OpenGL 绘制。&lt;/p&gt;
&lt;p&gt;绘制的话直接用了以下代码：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;glEnable(GL_TEXTURE_RECTANGLE);

bind();
glBegin ( GL_QUADS );
    glTexCoord2f (     0,      0 ); glVertex2f ( -1.0F, -1.0F );
    glTexCoord2f (     0, height ); glVertex2f ( -1.0F,  1.0F );
    glTexCoord2f ( width, height ); glVertex2f (  1.0F,  1.0F );
    glTexCoord2f ( width,      0 ); glVertex2f (  1.0F, -1.0F );
glEnd ( );
unBind();

glDisable(GL_TEXTURE_RECTANGLE);&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;似乎有更快的方法，使用 &lt;code&gt;glDrawPixels&lt;/code&gt;，但是上面这方法绘制1080P每一帧也只用了 0.1ms ，于是乎懒得再继续折腾了&lt;/p&gt;
&lt;p&gt;另外有个蛋疼的事情是， OpenCL 中的 float3 实际上就是 float4，如果你用一个 float3 指针指向一个地址修改，他会把最后第四位赋值为 0，这点挺坑爹的。&lt;/p&gt;
&lt;hr /&gt;
&lt;h3 id=&quot;参考文章&quot;&gt;参考文章&lt;/h3&gt;
&lt;ol type=&quot;1&quot;&gt;
&lt;li&gt;&lt;a href=&quot;http://www.songho.ca/opengl/gl_pbo.html&quot;&gt;FBO,PBO,VBO都介绍的超详细而且带demo&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://code.google.com/p/rtrt-on-gpu/&quot;&gt;OpenCL,OpenGL，GLSL实现的光线跟踪&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://blog.csdn.net/xiajun07061225/article/details/7283929&quot;&gt;[1]的翻译&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://sa09.idav.ucdavis.edu/docs/SA09_GL_interop.pdf&quot;&gt;OpenCL操作FBO&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
</description>
                <link>http://cjld.github.io/2013/10/11/clshgl</link>
                <guid>http://cjld.github.io/2013/10/11/clshgl</guid>
                <pubDate>2013-10-11T00:00:00+08:00</pubDate>
        </item>

        <item>
                <title>流水账</title>
                <description>&lt;p&gt;Blog好久没动了，于是乎随便记一点流水账，更新下&lt;code&gt;TODO list&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;windows下各种开发环境重装了一遍。&lt;/p&gt;
&lt;p&gt;jekyll如果出现错误&lt;code&gt;Liquid Exception: Invalid Byte Sequence in GBK in ***&lt;/code&gt;，需要改以下两处：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#C:\Ruby200-x64\lib\ruby\gems\2.0.0\gems\jekyll-1.2.1\lib\jekyll\converter.rb
self.content = File.read(File.join(base, name), :encoding =&amp;gt; &amp;quot;utf-8&amp;quot;)
#C:\Ruby200-x64\lib\ruby\gems\2.0.0\gems\jekyll-1.2.1\lib\jekyll\tags\include.rb
source = File.read(File.join(includes_dir, @file), :encoding =&amp;gt; &amp;quot;utf-8&amp;quot;)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;最近从唧唧那里400rmb入了个显示屏，从淘宝600入了个leapmotion，打算随便做点小开发熟悉下了leapmotion的SDK。&lt;/p&gt;
&lt;p&gt;有点 想抛弃vim了，于是乎开始折腾sublimeText，感觉不错，支持python。&lt;/p&gt;
&lt;p&gt;实时动画图形学这门课要学用3dsmax建模，但是一向对这种大型软件无爱，于是乎开始研究更有生命力的开源软件blender，也支持python。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://december.github.io/&quot;&gt;师座的github blog&lt;/a&gt;也搭起来了，很大方美观，有时间我也装修一下。&lt;/p&gt;
&lt;p&gt;图形课要开始高能了，ldengine也要开始动工了。&lt;/p&gt;
&lt;p&gt;今天最高兴的一件事情：OpenCL居然比CUDA快，当然这个测试也许不太靠谱，只是求了个斐波那契数列和，不过我担心nvidia不待见OpenCL故意让她变慢的顾虑算是打消了。&lt;/p&gt;
&lt;p&gt;在about页加了友链，更新了sandbox&lt;/p&gt;
</description>
                <link>http://cjld.github.io/2013/10/02/dtdaccount</link>
                <guid>http://cjld.github.io/2013/10/02/dtdaccount</guid>
                <pubDate>2013-10-02T00:00:00+08:00</pubDate>
        </item>

        <item>
                <title>用Markdown做ppt</title>
                <description>&lt;p&gt;小学期开始了，课上要求每个同学都要做简短展示，看到最近流行起来的用html5做ppt的技术，加之电脑上又没有装office，于是乎索性想折腾一下用markdown写ppt。&lt;/p&gt;
&lt;p&gt;在网上挑了半天以后，决定用 &lt;code&gt;landslide&lt;/code&gt;和&lt;code&gt;google html5slides&lt;/code&gt; 来折腾，一来是比较轻量级，最后可以编译出单个html不超过100k，二来是简介大方并且可定制。当然还有一些重量级的html5 slide制作工具，比如&lt;code&gt;Reveal.js&lt;/code&gt;，但是大多需要ruby环境，于是乎懒得折腾了。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;google html5slides&lt;/code&gt;就是一套js代码，用起来很方便，而&lt;code&gt;landslide&lt;/code&gt;做的就是简单地吧markdown翻译了以后生成html，用python开发的。&lt;/p&gt;
&lt;p&gt;用 &lt;code&gt;---&lt;/code&gt; 来做分页，源码如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# Landslide

---

# Overview

Generate HTML5 slideshows from markdown, ReST, or textile.

![python](http://i.imgur.com/bc2xk.png)

Landslide is primarily written in Python, but it&amp;#39;s themes use:

- HTML5
- Javascript
- CSS

---

# Code Sample

Landslide supports code snippets

    !python
    def log(self, message, level=&amp;#39;notice&amp;#39;):
        if self.logger and not callable(self.logger):
            raise ValueError(u&amp;quot;Invalid logger set, must be a callable&amp;quot;)

        if self.verbose and self.logger:
            self.logger(message, level)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;花了半个小时捏css以后，一个简单的ppt出炉了，大家可以戳&lt;a href=&quot;http://cjld.github.io/slides/sum_pt.html&quot;&gt;⇒这里⇐&lt;/a&gt;围观~&lt;/p&gt;
&lt;p&gt;意外的发现 &lt;code&gt;本座倒要看看你能活几天&lt;/code&gt; 这个游戏的BGM &lt;code&gt;it&#39;s only the fairy tale&lt;/code&gt; 挺好听的，游戏没玩专门听BGM去了。&lt;/p&gt;
</description>
                <link>http://cjld.github.io/2013/09/05/landslide</link>
                <guid>http://cjld.github.io/2013/09/05/landslide</guid>
                <pubDate>2013-09-05T00:00:00+08:00</pubDate>
        </item>

        <item>
                <title>Markdown段落缩进</title>
                <description>&lt;p&gt;Markdown虽然写起文章来非常舒畅，让人的写作欲望很强，但是用了这么段时间发现发现一个不太好的地方，Markdown不支持段落缩进！&lt;/p&gt;
&lt;p&gt;不支持段落缩进还是挺要命的，代码没有缩进可读性几乎为0，文章没有段落缩进层次感大大降低，Markdown里打的空格都会被吞掉，打多了又会变成代码块。&lt;/p&gt;
&lt;p&gt;稍微查了查，有两种方法来实现段落缩进：&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id=&quot;使用列表&quot;&gt;使用列表&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;h2&gt;一级标题&lt;/h2&gt;
&lt;p&gt;文字文字&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;h3&gt;二级标题&lt;/h3&gt;
文字文字&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;文字文字&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;h3&gt;二级标题&lt;/h3&gt;
文字文字&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;代码如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;*   ##一级标题

    文字文字

    *   ###二级标题

        文字文字

    文字文字

    *   ###二级标题

        文字文字&lt;/code&gt;&lt;/pre&gt;
&lt;hr /&gt;
&lt;h2 id=&quot;使用区块引用&quot;&gt;使用区块引用&lt;/h2&gt;
&lt;h2 id=&quot;一级标题-1&quot;&gt;一级标题&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;文字文字&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;文字文字&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;h3&gt;二级标题&lt;/h3&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;文字文字&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;文字文字&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;h3&gt;二级标题&lt;/h3&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;文字文字&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;代码块&lt;/code&gt;&lt;/pre&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;
&lt;p&gt;代码:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;##一级标题

&amp;gt; 文字文字

&amp;gt; 文字文字

&amp;gt; ###二级标题

&amp;gt; &amp;gt; 文字文字

&amp;gt; 文字文字

&amp;gt; ###二级标题

&amp;gt; &amp;gt; 文字文字
&amp;gt; &amp;gt;
    代码块&lt;/code&gt;&lt;/pre&gt;
&lt;hr /&gt;
&lt;p&gt;感觉用区块引用不错，列表毕竟还是有自己的用处。&lt;/p&gt;
</description>
                <link>http://cjld.github.io/2013/08/12/mksection</link>
                <guid>http://cjld.github.io/2013/08/12/mksection</guid>
                <pubDate>2013-08-12T00:00:00+08:00</pubDate>
        </item>

        <item>
                <title>在Qt下共享openGL与openCL缓存</title>
                <description>&lt;p&gt;openCL的使用常常需要和openGL搭配起来，glut不错的选择，不过由于本人比较喜欢Qt，于是直接使用了QGLWidget进行绘图。&lt;/p&gt;
&lt;p&gt;本文重点是介绍如何共享openCL和openGL的缓存(VBO)，和VBO的简单应用。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;img src=&quot;../../../../img/qgl_clbuffer.png&quot; /&gt; &amp;gt;在QGLWidget下实现的openGL应用，其中正弦函数部分由openCL计算，&lt;a href=&quot;https://github.com/cjld/QGL-BufferCLshare&quot;&gt;Fork me on Github&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;简单的QGLWidget框架可以参考这篇→&lt;a href=&quot;http://qiliang.net/old/nehe_qt/&quot;&gt;Qt OpenGL教程&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;从opengl中创建使用vbo&quot;&gt;&lt;strong&gt;从openGL中创建使用VBO&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;从openGL的角度来看，使用VBO（顶点缓存器）的几个步骤：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;创建顶点缓存器&lt;/li&gt;
&lt;li&gt;绑定（bind）顶点缓存器&lt;/li&gt;
&lt;li&gt;使用顶点缓存器绘制&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;因为在qt里好像没有找到glBindBuffer这么些函数，于是乎只好用Qt自己封装好的QGLBuffer，使用起来还比较方便&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;buffer=new QGLBuffer(QGLBuffer::VertexBuffer);
buffer-&amp;gt;create();
//相当于glGenBuffer

buffer-&amp;gt;bind();
//相当于glBindBuffer

buffer-&amp;gt;allocate(sizeof(GLfloat)*2048*2);
//相当于glBufferData

buffer-&amp;gt;bind();
//绑定，绘制准备

glEnableClientState(GL_VERTEX_ARRAY);
glVertexPointer(2,GL_FLOAT,0,0);
glColor3f(1,1,0);
glDrawArrays(GL_LINE_STRIP,0,2048);
//绘制&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;有一个坑爹的地方，一定要先create再bind再alloccate，乱了就什么也画不出来。&lt;/p&gt;
&lt;h2 id=&quot;openclopengl共用vbo&quot;&gt;&lt;strong&gt;openCL&amp;amp;openGL共用VBO&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;openCL如果需要和openGL共享buffer，大致步骤如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;创建一个支持openGL的上下文&lt;/li&gt;
&lt;li&gt;从openGL已经创建好的VBO创建一个openCL buffer&lt;/li&gt;
&lt;li&gt;连接buffer，释放buffer&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;我将这些东西封装到了 &lt;code&gt;ldCLtempl.h&lt;/code&gt;，使用方法如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;ldcl.init(wglGetCurrentContext(),wglGetCurrentDC());
//创建支持openGL的上下文

ldcl.setArg(buffer-&amp;gt;bufferId(),CL_MEM_READ_WRITE);
//共享buffer&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;ldCLtempl.h&lt;/code&gt;的实现方法如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;void init(HGLRC glContext, HDC glDisplay) {
  cl::Platform::get(&amp;amp;platformList);
  printPlatformInfo();

  platformList[pid].getDevices(CL_DEVICE_TYPE_ALL,&amp;amp;deviceList);
  printDeviceInfo();

  cl_context_properties props[]={
    CL_GL_CONTEXT_KHR, (cl_context_properties)glContext,
    CL_WGL_HDC_KHR, (cl_context_properties)glDisplay,
    CL_CONTEXT_PLATFORM, (cl_context_properties)platformList[pid](), 0
  };
  context=new cl::Context(deviceList, props);
  //创建支持openGL的上下文

  cmdQueue=new cl::CommandQueue(*context,deviceList[did]);
}

struct myBufferGL : public myBuffer {
  vector&amp;lt;cl::Memory&amp;gt; mv;
  myBufferGL(LDCL *fa, cl_mem_flags flags, GLuint bufobj) : myBuffer(fa,flags,0,0,0) {
    buffer=new cl::BufferGL(*(fa-&amp;gt;context),flags,bufobj);
    //通过从openGL已经创建的buffer创建
    mv.push_back(*buffer);
  }
  virtual void beforeRun() {father-&amp;gt;cmdQueue-&amp;gt;enqueueAcquireGLObjects(&amp;amp;mv);}
  //从openGL获取buffer的控制权
  virtual void afterRun() {father-&amp;gt;cmdQueue-&amp;gt;enqueueReleaseGLObjects(&amp;amp;mv);}
  //释放控制权
  ~myBufferGL() {}
};&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;纹理缓存的使用方法类似。&lt;/p&gt;
&lt;p&gt;另外书上写的在执行openCL之前得先执行&lt;code&gt;glFinish()&lt;/code&gt;，不过我没有执行也可以用，而且发现openCL是同步执行而不是异步执行的，似乎显卡是否支持同步有关。&lt;/p&gt;
</description>
                <link>http://cjld.github.io/2013/08/11/qglandcl</link>
                <guid>http://cjld.github.io/2013/08/11/qglandcl</guid>
                <pubDate>2013-08-11T00:00:00+08:00</pubDate>
        </item>

        <item>
                <title>在openCL中实现全局同步</title>
                <description>&lt;p&gt;全局同步是一个至关重要的功能，可是限于硬件，openCL内部并没有现成的全局同步函数，在网上搜了一阵子无果后，遂开始自己琢磨如何实现全局同步。&lt;/p&gt;
&lt;p&gt;要实现全局同步并不难，难就难在如何高效的实现全局同步，这里我用了这样一种评测方法：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;kernel void main(volatile global int *a, global int *flags) {
  int i=get_global_id(0);
  
  FOR(j,0,500000) {
    int temp=a[i]+a[(i+1)&amp;amp;(N-1)]+a[(i+2)&amp;amp;(N-1)];
    globalSync(flags);
    a[i]=temp;
    globalSync(flags);
  }
}&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;总进程数2048，一开始a数组全赋值为1。&lt;/li&gt;
&lt;li&gt;同步成功的判定是最后a数组中的值全部一样，若中途同步失败，极大概率导致最后结果不一样&lt;/li&gt;
&lt;li&gt;测时间来评定全局同步方法的优劣&lt;/li&gt;
&lt;li&gt;注：不加同步函数时运行时间为220ms&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;很快，一个最暴力的想法就有了。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;申请一个全局计数器flags，初始化为0&lt;/li&gt;
&lt;li&gt;每次运行到同步函数的时候，用原子函数+1&lt;/li&gt;
&lt;li&gt;用循环不停的检测flags是否等于总进程数&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;代码如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;  void globalSync1(volatile global int *s) {
    atomic_inc(s);
    while (*s!=get_global_size(0));
    if (get_global_id(0)==0) atomic_sub(s,get_global_size(0));
  }&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;测试结果：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;工作组大小 1024 耗时 3020ms&lt;/li&gt;
&lt;li&gt;工作组大小 64 耗时 3021ms&lt;/li&gt;
&lt;li&gt;工作组大小 32 耗时 10000+ms&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;效率不高，好歹能用，而且代码短。不过这里有个小陷阱，就是volatile限定符，如果不加volatile限定符，会导致在重复访问相同地址时，会直接返回之前寄存器保存的变量，加volatile限定符相当于告诉他这个变量在其他进程会被更改。&lt;/p&gt;
&lt;p&gt;方法一效率瓶颈在于原子函数，减少原子函数的调用次数是优化的重点。于是乎，通过利用barrier可以想到方法二：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;仍然是计数器flags清零&lt;/li&gt;
&lt;li&gt;每个工作组选出一个代表元，比如&lt;code&gt;get_local_id(0)==0&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;如果该进程不是代表元，用barrier拦住&lt;/li&gt;
&lt;li&gt;如果该进程为代表元，计数器+1，用循环不停的检测flags是否等于总工作组数&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;代码：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;  void globalSync2(volatile global int *s) {
    if (get_local_id(0)==0) {
      atomic_inc(s);
      while (*s!=get_num_groups(0));
    };
    barrier(CLK_GLOBAL_MEM_FENCE | CLK_LOCAL_MEM_FENCE);
    if (get_global_id(0)==0) atomic_sub(s,get_num_groups(0));
  }&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;测试结果：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;工作组大小 1024 耗时 1020ms&lt;/li&gt;
&lt;li&gt;工作组大小 64 耗时 1024ms&lt;/li&gt;
&lt;li&gt;工作组大小 32 耗时 10000+ms&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;有了明显的改善，但是工作组比较小的时候用这个函数来同步任然是不可取的。&lt;/p&gt;
&lt;p&gt;想到这里我就没继续深究了，又胡乱google了一通，找到这么一篇英文文章:&lt;a href=&quot;http://industrybestpractice.blogspot.com/2012/07/global-synchronisation-in-opencl.html&quot;&gt;http://industrybestpractice.blogspot.com/2012/07/global-synchronisation-in-opencl.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;文中作者介绍了三个方法，前两个和我想的一样，作者基于第二个方法想出了第三个方法，不需要用到原子函数的方法：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;仍然是每个工作组找出个代表元&lt;/li&gt;
&lt;li&gt;定义第一个工作组为代表工作组，这个工作组负责管理每个工作组的代表元&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这样就形成了3层结构，一层一层往下管理，不得不说作者的思路很巧妙，代码：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;  void globalSync3(volatile global int *s) {
    const int lid=get_local_id(0);
    const int gid=get_group_id(0);
    if (!lid) s[gid]=1;
    if (!gid) {
      if (lid&amp;lt;get_num_groups(0))
        while (!s[lid]);
      barrier(CLK_GLOBAL_MEM_FENCE | CLK_LOCAL_MEM_FENCE);
      s[lid]=0;
    }
    while (!lid &amp;amp;&amp;amp; s[gid]);
    barrier(CLK_GLOBAL_MEM_FENCE | CLK_LOCAL_MEM_FENCE);
  }&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;测试结果：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;工作组大小 1024 耗时 1405ms&lt;/li&gt;
&lt;li&gt;工作组大小 64 耗时 1377ms&lt;/li&gt;
&lt;li&gt;工作组大小 32 耗时 10000+ms&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;虽然方法很巧妙，却不如第2个方法来的简单粗暴，而且看了代码的读者很轻易的可以发现，第3个方法有不少缺点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;需要一个标记数组&lt;/li&gt;
&lt;li&gt;工作组大小必须大于工作组个数&lt;/li&gt;
&lt;li&gt;速度稍慢&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;综上所述，第2个方法也许我会一直用下去。&lt;/p&gt;
&lt;p&gt;测试代码可在 &lt;a href=&quot;https://github.com/cjld/opencl1/tree/master/globalSync&quot;&gt;https://github.com/cjld/opencl1/tree/master/globalSync&lt;/a&gt; 下载。&lt;/p&gt;
&lt;p&gt;欢迎拍砖&lt;/p&gt;
</description>
                <link>http://cjld.github.io/2013/08/05/globalsync</link>
                <guid>http://cjld.github.io/2013/08/05/globalsync</guid>
                <pubDate>2013-08-05T00:00:00+08:00</pubDate>
        </item>

        <item>
                <title>超简易openCL api</title>
                <description>&lt;p&gt;虽说openCL有个简单的c++封装器，不过还是很麻烦呢，一大坨代码，能向CUDA一样一句话搞定多好，遂半夜睡不着开始写超简易openCL api。&lt;/p&gt;
&lt;p&gt;成果图：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#include &amp;quot;ldCLtemplate.h&amp;quot;
#include &amp;lt;ctime&amp;gt;

#define N 2048
#define FOR(i,l,r) for (int i=(l);i&amp;lt;=(r);i++)

int a[N],b[N],c[N];

int main() {
  FOR(i,0,N-1) a[i]=b[i]=i;

  LDCL ldcl(&amp;quot;kernal.cl&amp;quot;,&amp;quot;adder&amp;quot;,cl::NDRange(N));
  ldcl.setArg(a, N*sizeof(a[0]), CL_MEM_READ_ONLY);
  ldcl.setArg(b, N*sizeof(b[0]), CL_MEM_READ_ONLY);
  ldcl.setArg(c, N*sizeof(b[0]), CL_MEM_WRITE_ONLY, LDCL_NEED_READ);
  ldcl.run();
}&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;还是要5行呢…，本来setArg那个地方想用个template来着，搞半天都没编译成功，遂放弃。&lt;/p&gt;
&lt;p&gt;文档什么也懒得写了……，反正我自己用的说，&lt;a href=&quot;https://github.com/cjld/opencl1/tree/master/ld_opencl_template&quot;&gt;github repo&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;今天还学了下原子函数的用法，原子函数相当于一个全局阻塞的函数，不过速度不咋滴。&lt;/p&gt;
&lt;p&gt;对这样一个kernal做了测试：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#define FOR(i,l,r) for (int i=(l);i&amp;lt;=(r);i++)

kernel void adder(constant int* a, constant int* b, global int* result)
{
  int idx = get_global_id(0);
  int x=1,y=2;
  FOR(i,1,100000) {
    atomic_add(result,result[1]);
    atomic_add(result+1,result[0]);
    atomic_add(result,result[1]);
    atomic_add(result+1,result[0]);
    atomic_add(result,result[1]);
    atomic_add(result+1,result[0]);
    atomic_add(result,result[1]);
    atomic_add(result+1,result[0]);
    atomic_add(result,result[1]);
    atomic_add(result+1,result[0]);
  }
}&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;复制这么多份目的是为了不让for循环本身成为主要的复杂度。&lt;/p&gt;
&lt;p&gt;测试发现，和工作组大小有非常大的关系：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;工作组大小：1024，耗时：3067ms&lt;/li&gt;
&lt;li&gt;工作组大小：512，耗时：3037ms&lt;/li&gt;
&lt;li&gt;工作组大小：256，耗时：2968ms&lt;/li&gt;
&lt;li&gt;工作组大小：128，耗时：2943ms&lt;/li&gt;
&lt;li&gt;工作组大小：64，耗时：2886ms&lt;/li&gt;
&lt;li&gt;工作组大小：32，耗时：5120ms&lt;/li&gt;
&lt;li&gt;工作组大小：16，耗时：7737ms&lt;/li&gt;
&lt;li&gt;工作组大小：8，耗时：9095ms&lt;/li&gt;
&lt;li&gt;工作组大小：4，耗时：11587ms&lt;/li&gt;
&lt;li&gt;工作组大小：2，耗时：12355ms&lt;/li&gt;
&lt;li&gt;工作组大小：1，耗时：18766ms&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;工作组大小为64是最优值，这是为什么？貌似我的 CL_DEVICE_MAX_WORK_ITEM_SIZES 的最后一维是64，而且低于64耗时快速攀升，不解，有空上stackoverflow去问问，总之以后尽量吧工作组开大和避免使用过多的原子函数就好了吧。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;更新日志&lt;/em&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;2013/10/11
&lt;ul&gt;
&lt;li&gt;代码重写为&lt;code&gt;DOpenCL&lt;/code&gt;，增加对buffer，function，context的管理，内存可由 DOpenCL 类统一管理&lt;/li&gt;
&lt;li&gt;&lt;code&gt;DCLGL.h&lt;/code&gt; 增加&lt;code&gt;DCLBufferGL&lt;/code&gt;,&lt;code&gt;DCLImageGL&lt;/code&gt;,&lt;code&gt;DCLRenderBufferGL&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;新仓库地址&lt;a href=&quot;https://github.com/cjld/DLIB&quot;&gt;https://github.com/cjld/DLIB&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;2013/8/11 &lt;em&gt;增加bufferGL&lt;/em&gt;&lt;/li&gt;
&lt;li&gt;2013/8/5 &lt;em&gt;local不能设置的bug&lt;/em&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
                <link>http://cjld.github.io/2013/08/03/supersimpleclapi</link>
                <guid>http://cjld.github.io/2013/08/03/supersimpleclapi</guid>
                <pubDate>2013-08-03T00:00:00+08:00</pubDate>
        </item>

        <item>
                <title>openCL同步函数</title>
                <description>&lt;p&gt;在并行程序里，做到同步并且效率不会下降是一件很麻烦的事情，openCL里有几个用来同步的函数，简单学习下。&lt;/p&gt;
&lt;p&gt;笔者为新手，文章都是学习笔记，有些地方靠自己猜测，有错误还希望指出~&lt;/p&gt;
&lt;h2 id=&quot;barrier&quot;&gt;barrier&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;void barrier (cl_mem_fence_flags flags)&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;只能同步同一个工作组内部的函数。&lt;/li&gt;
&lt;li&gt;cl_mem_fence_flags:&lt;/li&gt;
&lt;li&gt;CLK_LOCAL_MEM_FENCE&lt;/li&gt;
&lt;li&gt;CLK_GLOBAL_MEM_FENCE&lt;/li&gt;
&lt;li&gt;&lt;code&gt;CLK_LOCAL_MEM_FENCE&lt;/code&gt; 和 &lt;code&gt;CLK_GLOBAL_MEM_FENCE&lt;/code&gt; 的区别&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这里用到的memfence技术，并不是真真意义上的同步，而是变量读写上保证同步，大体可以这样理解，在memfence保证了在barrier之前的“写”操作在barrier之后的“读”操作之前，不过好像也不完全是（reference上看不大明白）。&lt;/p&gt;
&lt;p&gt;总之，要用local变量的时候就用&lt;code&gt;barrier(CLK_LOCAL_MEM_FENCE)&lt;/code&gt;,要用global变量是就用&lt;code&gt;barrier(CLK_GLOBAL_MEM_FENCE)&lt;/code&gt;，保险起见还可以用&lt;code&gt;barrier(CLK_LOCAL_MEM_FENCE | CLK_GLOBAL_MEM_FENCE)&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;另外openCL里也有&lt;code&gt;void mem_fence(cl_mem_fence_flags flags)&lt;/code&gt;，用法感觉和barrier差不多，区别在于，barrier相当于一个全工作组的mem fence，只有工作组里所有进程都过了mem fence，大家才会一起继续执行。&lt;/p&gt;
&lt;h2 id=&quot;关于工作组&quot;&gt;关于工作组&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;每个group的local空间很小，比如gt750m是&lt;code&gt;49152 byte&lt;/code&gt;，只够开10000多个int&lt;/li&gt;
&lt;li&gt;local 工作组大小必须是 global 大小的约数，而且local也不能太大，我的是1024&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;异步复制函数&quot;&gt;异步复制函数&lt;/h2&gt;
&lt;p&gt;感觉没啥用呢…手写复制难道会慢很多么，又不是硬盘IO操作。&lt;/p&gt;
&lt;p&gt;另外最近找到了个大大翻译的中文reference，地址&lt;a href=&quot;http://github.com/downloads/walkthetalk/contextstudy/opencl-spec-zh-beta2.pdf&quot;&gt;http://github.com/downloads/walkthetalk/contextstudy/opencl-spec-zh-beta2.pdf&lt;/a&gt; ，&lt;a href=&quot;https://niqingliang2003.wordpress.com/&quot;&gt;这里&lt;/a&gt;是他的blog。&lt;/p&gt;
</description>
                <link>http://cjld.github.io/2013/07/31/openclasync</link>
                <guid>http://cjld.github.io/2013/07/31/openclasync</guid>
                <pubDate>2013-07-31T00:00:00+08:00</pubDate>
        </item>

        <item>
                <title>openCL内核地址空间限定符</title>
                <description>&lt;p&gt;本文介绍opencl一些限定符的运用&lt;/p&gt;
&lt;h2 id=&quot;kernel内核限定符&quot;&gt;kernel内核限定符&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;返回值必须是void&lt;/li&gt;
&lt;li&gt;参数的一些限制，不能是私有。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;内核属性限定符&quot;&gt;内核属性限定符&lt;/h2&gt;
&lt;h2 id=&quot;地址空间限定符&quot;&gt;地址空间限定符&lt;/h2&gt;
&lt;p&gt;如果没有加限定符，则默认为private。&lt;/p&gt;
&lt;p&gt;由不同限定符限定的指针之间不能转换。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;global&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;全局地址空间限定符，表示指向的地址空间为全局公用的。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;constant&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;全局常量地址空间限定符，相当于只读全局地址空间,&lt;strong&gt;只有constant可以声明在全局变量里&lt;/strong&gt;，如下。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;  global long4 g;    // illegal
  private int x;     // illegal
  local int p;       // illegal
  constant int y;    // legal
   
  kernel void kernelMain(global int *p) {
    ...
  }&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;local&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;局部地址空间限定符，trick最多的一种类型，因为显卡局部显存和全局显存速度的差异性，导致这么一种东西的诞生。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;不允许初始化,&lt;strong&gt;注意：由local限定的指针可以初始化&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;只允许申请在内核函数的最外层声明,&lt;strong&gt;指针可以随意申请&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;&lt;p&gt;不能由宿主程序赋值。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;private&lt;/strong&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;最正常的限定符，类似于平时写串行程序的变量。&lt;/p&gt;
&lt;p&gt;访问限定符&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;write_only&lt;/li&gt;
&lt;li&gt;read_only&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;另外，opencl不支持任何形式的new，也就是说他所有空间都是静态的，所以递归什么的也是不行的，这个挺让人捉急的…&lt;/p&gt;
&lt;p&gt;由于本人水平有限，刚开始初学，所以内容也许有错误，欢迎批评指正。&lt;/p&gt;
</description>
                <link>http://cjld.github.io/2013/07/22/qual</link>
                <guid>http://cjld.github.io/2013/07/22/qual</guid>
                <pubDate>2013-07-22T00:00:00+08:00</pubDate>
        </item>

        <item>
                <title>openCL C++ 封装api学习</title>
                <description>&lt;p&gt;openCL同样也有自己的c++包装器，因为本质还是基于原来的c实现的，只不过用了一些c++的特性来简化编程，所以只需要一个单独的头文件就可以了。&lt;/p&gt;
&lt;p&gt;单独需要的头文件为 &lt;code&gt;cl.hpp&lt;/code&gt;，我将不同版本的&lt;code&gt;cl.hpp&lt;/code&gt;和官方的reference放到&lt;a href=&quot;https://github.com/cjld/opencl1/tree/master/opencl_c%2B%2B&quot;&gt;这里&lt;/a&gt;了，使用的时候直接将&lt;code&gt;#include &amp;lt;CL/cl.h&amp;gt;&lt;/code&gt;改为&lt;code&gt;#include &amp;lt;CL/cl.hpp&amp;gt;&lt;/code&gt;即可。&lt;/p&gt;
&lt;p&gt;另外由于CUDA暂时不支持1.2，得先用1.1的&lt;code&gt;cl.hpp&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;有了c++的包装以后opencl的结构显得清晰多了，下面一一列举几个模块的用法：&lt;/p&gt;
&lt;ol type=&quot;1&quot;&gt;
&lt;li&gt;&lt;p&gt;错误信息获取&lt;/p&gt;
&lt;p&gt;经过c++包装过的错误信息可以很方便的获取了，使用的是c++的try-throw-catch机制。 之前还从来没听说过这种玩意，稍微Google了下，用法大概如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;try {
  ...          
  throw x;
  ...
} catch(A a) {
  ...
}&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;假设throw出来的x类型正好为A的话，就会将x赋值给a，然后执行catch代码块里的东西，在过程里的throw同样有效。&lt;/p&gt;
&lt;p&gt;想要在openCL C++ wrapper里使用，就必须定义宏：&lt;code&gt;#define __CL_ENABLE_EXCEPTIONS&lt;/code&gt;，然后使用如下代码抓取错误：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;try {

  ...

} catch (cl::Error err) {
  cerr&amp;lt;&amp;lt;&amp;quot;ERROR : &amp;quot;&amp;lt;&amp;lt;err.what()&amp;lt;&amp;lt;&amp;#39;(&amp;#39;&amp;lt;&amp;lt;err.err()&amp;lt;&amp;lt;&amp;#39;)&amp;#39;&amp;lt;&amp;lt;endl;
}&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Platform获取&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;vector&amp;lt;cl::Platform&amp;gt; platformList;
cl::Platform::get(&amp;amp;platformList);&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Platform info&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;void printPlatformInfo(vector&amp;lt;cl::Platform&amp;gt; &amp;amp;list) {
  cout&amp;lt;&amp;lt;endl&amp;lt;&amp;lt;&amp;quot;Platform size : &amp;quot;&amp;lt;&amp;lt;list.size()&amp;lt;&amp;lt;endl;
  const char name[][20]={&amp;quot;PROFILE&amp;quot;,&amp;quot;VERSION&amp;quot;,&amp;quot;NAME&amp;quot;,&amp;quot;VENDOR&amp;quot;,&amp;quot;EXTENSIONS&amp;quot;};
  for (size_t i=0; i&amp;lt;list.size(); i++) {
    cout&amp;lt;&amp;lt;endl;
    for (size_t j=0; j&amp;lt;=4; j++) {
      string info;
      list[i].getInfo((cl_platform_info)(CL_PLATFORM_PROFILE+j),&amp;amp;info);
      cout&amp;lt;&amp;lt;name[j]&amp;lt;&amp;lt;&amp;quot; : &amp;quot;&amp;lt;&amp;lt;info&amp;lt;&amp;lt;endl;
    }
  }
}&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Device获取&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;vector&amp;lt;cl::Device&amp;gt; deviceList;
platformList[0].getDevices(CL_DEVICE_TYPE_ALL,&amp;amp;deviceList);&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Device info&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;void printDeviceInfo(vector&amp;lt;cl::Device&amp;gt; &amp;amp;list) {
  cout&amp;lt;&amp;lt;endl&amp;lt;&amp;lt;&amp;quot;Device size : &amp;quot;&amp;lt;&amp;lt;list.size()&amp;lt;&amp;lt;endl;
  for (size_t i=0; i&amp;lt;list.size(); i++) {
    cout&amp;lt;&amp;lt;endl;
    string info;
    list[i].getInfo(CL_DEVICE_NAME,&amp;amp;info);
    cout&amp;lt;&amp;lt;&amp;quot;name : &amp;quot;&amp;lt;&amp;lt;info&amp;lt;&amp;lt;endl;
    cl_uint size;
    list[i].getInfo(CL_DEVICE_MAX_WORK_ITEM_DIMENSIONS,&amp;amp;size);
    cout&amp;lt;&amp;lt;&amp;quot;max dim number : &amp;quot;&amp;lt;&amp;lt; list[i].getInfo&amp;lt;CL_DEVICE_MAX_WORK_ITEM_DIMENSIONS&amp;gt;() &amp;lt;&amp;lt;endl;
    vector&amp;lt;size_t&amp;gt; sizes=list[i].getInfo&amp;lt;CL_DEVICE_MAX_WORK_ITEM_SIZES&amp;gt;();
    cout&amp;lt;&amp;lt;&amp;quot;max work item size : &amp;quot;;
    for (size_t j=0;j&amp;lt;sizes.size();j++)
      cout&amp;lt;&amp;lt;sizes[j]&amp;lt;&amp;lt;&amp;quot; &amp;quot;;
    cout&amp;lt;&amp;lt;endl;
 //   cout&amp;lt;&amp;lt;&amp;quot;max sub device : &amp;quot;&amp;lt;&amp;lt;CL_DEVICE_PARTITION_MAX_SUB_DEVICES&amp;lt;&amp;lt;endl;
  }
}&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这里有个比较有意思的地方，就是getInfo，这里用了模板，因为这个函数的返回值随着枚举类的不同返回值也是不一样的，当然，以前的用法也是允许的。&lt;/p&gt;
&lt;p&gt;另外最近才得知，原来大部分显卡都最多支持3维，如我的GT750m，输出&lt;code&gt;CL_DEVICE_MAX_WORK_ITEM_DIMENSIONS&lt;/code&gt;，得出就是3。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;SubContext&lt;/p&gt;
&lt;p&gt;openCL1.2的特性，目的可以将一部分计算资源腾出来供ui操作或者其他。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;cl_int createSubDevices(
    const cl_device_partition_property_ext * properties,
    VECTOR_CLASS&amp;lt;Device&amp;gt;* devices);&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;用法和&lt;code&gt;clCreateSubDevices&lt;/code&gt;类似，详见&lt;a href=&quot;http://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/clCreateSubDevices.html&quot;&gt;这里&lt;/a&gt;;&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Context&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;cl::Context context(deviceList);&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;简单明了，多么舒畅，虽然context也有其他创建方法，但都不如这个简洁，这一步可以省去参数&lt;code&gt;cl_context_properties&lt;/code&gt;。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;CommandQueue&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;cl::CommandQueue cmdQueue(context,deviceList[0]);&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Program &amp;amp; Build&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;cl::Program::Sources src(
    1,
    make_pair(getAllFile(&amp;quot;kernal1.cpp&amp;quot;),0)
);

cl::Program program(context,src);
program.build(deviceList);&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Kernel &amp;amp; Buffer&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;cl::Buffer bufferA(context, CL_MEM_READ_ONLY, LIST_SIZE * sizeof(int));
cl::Buffer bufferB(context, CL_MEM_READ_ONLY, LIST_SIZE * sizeof(int));
cl::Buffer bufferC(context, CL_MEM_WRITE_ONLY, LIST_SIZE * sizeof(int));

cl::Kernel kernel(program, &amp;quot;adder&amp;quot;);
kernel.setArg(0, bufferA);
kernel.setArg(1, bufferB);
kernel.setArg(2, bufferC);&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;write Buffer &amp;amp; set Kernel Dim&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;int A[LIST_SIZE];
for (int i=0;i&amp;lt;LIST_SIZE;i++) A[i]=i;
cmdQueue.enqueueWriteBuffer(bufferA, CL_TRUE, 0, LIST_SIZE * sizeof(int), A);
cmdQueue.enqueueWriteBuffer(bufferB, CL_TRUE, 0, LIST_SIZE * sizeof(int), A);

cmdQueue.enqueueNDRangeKernel(kernel, cl::NDRange(), cl::NDRange(LIST_SIZE), cl::NDRange());&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这里的&lt;code&gt;NDRange&lt;/code&gt;比较有意思，他有4个构造函数，分别是带0~3个参数，以此代表维度，&lt;code&gt;cl::NDRange(5,6,7)&lt;/code&gt;意思就是3维，每个维度大小分别为5,6,7。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;read Buffer&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;cmdQueue.enqueueReadBuffer(bufferC, CL_TRUE, 0, LIST_SIZE * sizeof(int), A);&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;总的来说还是挺清晰明了的呢,openCL C++ wrapper 比原来的代码结构清晰多了，另外&lt;code&gt;cl.hpp&lt;/code&gt;里面的代码可读性也很高，有时候不需要查手册直接翻源文件就好了。&lt;/p&gt;
</description>
                <link>http://cjld.github.io/2013/07/22/clcwrapper</link>
                <guid>http://cjld.github.io/2013/07/22/clcwrapper</guid>
                <pubDate>2013-07-22T00:00:00+08:00</pubDate>
        </item>

        <item>
                <title>解决windows GPU计算时间限制</title>
                <description>&lt;p&gt;windows如果发现单次GPU计算时间过长，会把这次计算任务直接掐掉钟来，目的是为了防止GPU出现死锁而无暇顾及桌面图形化界面，在win8以前是超过5s掐掉，win8是超过2s掐掉，症状是出现错误-5。&lt;/p&gt;
&lt;p&gt;这种机制被称为是 &lt;code&gt;TDR&lt;/code&gt;，可以禁用掉，详见&lt;a href=&quot;http://msdn.microsoft.com/en-us/library/windows/hardware/ff569918.aspx&quot;&gt;这里&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;直接禁用TDR:&lt;/p&gt;
&lt;p&gt;KeyPath : HKEY_LOCAL_MACHINEKeyValue : TdrLevel ValueType : REG_DWORD ValueData : TdrLevelOff (0) - Detection disabled TdrLevelBugcheck (1) - Bug check on detected timeout, for example, no recovery. TdrLevelRecoverVGA (2) - Recover to VGA (not implemented). TdrLevelRecover (3) - Recover on timeout. This is the default value.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;设置延时：&lt;/p&gt;
&lt;p&gt;KeyPath : HKEY_LOCAL_MACHINEKeyValue : TdrDelay ValueType : REG_DWORD ValueData : Number of seconds to delay. 2 seconds is the default value.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
                <link>http://cjld.github.io/2013/07/21/wingputimeout</link>
                <guid>http://cjld.github.io/2013/07/21/wingputimeout</guid>
                <pubDate>2013-07-21T00:00:00+08:00</pubDate>
        </item>

        <item>
                <title>vim配置文件打包</title>
                <description>&lt;p&gt;随着自己vim功能的增加，插件越来越多，决定把自己的vimfiles文件打包一个，并且还希望vimfiles不需要依赖外部文件，比如&lt;code&gt;ctags&lt;/code&gt;也一并打包进去。&lt;/p&gt;
&lt;p&gt;在github上创建了个新的repo，这时候发现个碍眼的东西，&lt;code&gt;_vimrc&lt;/code&gt;在&lt;code&gt;vimfiles&lt;/code&gt;文件夹的外面，&lt;code&gt;vimfiles&lt;/code&gt;里面的脚本文件vim不是也会自动运行一遍么？于是我把&lt;code&gt;_vimrc&lt;/code&gt;改名为&lt;code&gt;vimrc.vim&lt;/code&gt;放到了&lt;code&gt;vimfiles\plugin&lt;/code&gt;里面，发现同样也奏效了，于是乎就直接删掉原来的vimrc，用&lt;code&gt;vimfiles\plugin&lt;/code&gt;里面的代替，这样就可以做到vimfile和外部文件无关，下次再重装vim，一个&lt;code&gt;git clone&lt;/code&gt;，自己熟悉的vim就回来了~&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/cjld/vimfile&quot;&gt;github repo&lt;/a&gt;&lt;/p&gt;
</description>
                <link>http://cjld.github.io/2013/07/21/uploadvimfile</link>
                <guid>http://cjld.github.io/2013/07/21/uploadvimfile</guid>
                <pubDate>2013-07-21T00:00:00+08:00</pubDate>
        </item>

        <item>
                <title>Google-Code-Prettfy添加代码高亮</title>
                <description>&lt;p&gt;想给自己的jekyll blog加一下代码高亮,上网搜了下,有这么主流的三种方法:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Redcarpet Redcarpet作为markdown引擎可以使用以下代码来添加代码高亮&lt;/p&gt;
&lt;p&gt;``` ruby require ‘rubygems’&lt;/p&gt;
&lt;p&gt;def foo puts ‘foo’ end&lt;/p&gt;
&lt;p&gt;#comment ```&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;详见&lt;a href=&quot;http://ztpala.com/2011/10/27/code-highlighting-jekyll/&quot;&gt;这里&lt;/a&gt; * Pygments 应该是jekyll原生支持的方法，这个&lt;a href=&quot;http://zyzhang.github.io/blog/2012/08/31/highlight-with-Jekyll-and-Pygments/&quot;&gt;链接&lt;/a&gt;讲的比较详细。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Google-Code-Prettfy 通用的方法，Google造福人类，只要嵌入js和css即可。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;因为坑爹的windows原因，ruby各种抽风，所以我只能用最后一个办法了，&lt;a href=&quot;http://www.lidongkui.com/use-prettify-to-highlight-code&quot;&gt;这篇博文&lt;/a&gt;写的不错，利用jquery可以做到只需要改外部而不需要改&lt;code&gt;_post/&lt;/code&gt;文件夹下就可以实现代码高亮。&lt;/p&gt;
&lt;p&gt;效果测试：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#include &amp;lt;fuckly&amp;gt;

int main() {
  int a=1,b=a*a;
  return 0;
}&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;最后因为我在“关于页”和“零散页”滥用了pre标签，导致这些地方也有高亮了，不管了，还挺好看的。&lt;/p&gt;
&lt;p&gt;缺点还是有的，加载太慢了，用chrome打开以后要过将近一秒才能让代码高亮。&lt;/p&gt;
&lt;h3 id=&quot;updata&quot;&gt;&lt;strong&gt;UPDATA&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;过了一秒才出现的BUG查出来了，这个&lt;a href=&quot;http://www.lidongkui.com/use-prettify-to-highlight-code&quot;&gt;链接&lt;/a&gt;使用加载代码高亮效果的代码是：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$(window).load(function(){
     $(&amp;quot;pre&amp;quot;).addClass(&amp;quot;prettyprint&amp;quot;);
     prettyPrint();
})&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;因为jekyll使用了disqus，相当于他在等待disqus搞完以后才执行这段代码，因此直接改成这样就好了：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$(document).ready(function(){
     $(&amp;quot;pre&amp;quot;).addClass(&amp;quot;prettyprint&amp;quot;);
     prettyPrint();
})&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这样等待页面静态元素加载完就会执行这段代码，而不是等到disqus加载完。&lt;/p&gt;
</description>
                <link>http://cjld.github.io/2013/07/11/codehighlight</link>
                <guid>http://cjld.github.io/2013/07/11/codehighlight</guid>
                <pubDate>2013-07-11T00:00:00+08:00</pubDate>
        </item>

        <item>
                <title>OpenCL学习</title>
                <description>&lt;p&gt;&lt;code&gt;OpenCL&lt;/code&gt; &lt;a href=&quot;http://zh.wikipedia.org/wiki/OpenCL&quot;&gt;wiki&lt;/a&gt;,简单来说是一个用于并行计算设备的标准api，一开始觉得CUDA和OpenCL是竞争关系，后面稍微了解了以后才发现他们之间是包容关系。&lt;/p&gt;
&lt;p&gt;几乎所有平台都有实现openCL，intel,AMD,Nvidia,CUDA是Nvidia在openCL上又进行了封装和一些针对N卡优化的SDK，相比之openCL更容易上手，不得不吐槽openCL令人蛋碎的纯C用法。&lt;/p&gt;
&lt;p&gt;本文参考自 &lt;a href=&quot;http://blog.csdn.net/leonwei/article/category/1410041&quot;&gt;http://blog.csdn.net/leonwei/article/category/1410041&lt;/a&gt; ，作者写的很不错，让我能快速入门。&lt;/p&gt;
&lt;p&gt;买回来一本书结果发现讲的是openCL1.1的，2011年年底就已经出1.2标准了…国内资料的时效性还是不够啊，在网上找到了些比较权威的学习资料：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;官方reference&lt;a href=&quot;http://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/&quot;&gt;http://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;openCL1.2 overview&lt;a href=&quot;http://www.khronos.org/assets/uploads/developers/library/overview/opencl-overview.pdf&quot;&gt;http://www.khronos.org/assets/uploads/developers/library/overview/opencl-overview.pdf&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;官方入门教材 &lt;a href=&quot;http://developer.amd.com/wordpress/media/2012/10/opencl-1.2.pdf&quot;&gt;http://developer.amd.com/wordpress/media/2012/10/opencl-1.2.pdf&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;opencl架构&quot;&gt;OpenCL架构&lt;/h2&gt;
&lt;p&gt;笔者简单总结了下OpenCL的架构和一个简单的加法器实现，有错误还望指出:&lt;/p&gt;
&lt;ol type=&quot;1&quot;&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;Paltform&lt;/strong&gt; 平台，相当于不同厂商的OpenCL实现，比如intel实现了，AMD实现了并且我又同时装了两者的openCL sdk，那我就会有两者的平台。&lt;/p&gt;
&lt;p&gt;获得所有Platform函数：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;cl_int clGetPlatformIDs(
    cl_uint num_entries,
    cl_platform_id *platforms,
    cl_uint *num_platforms)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在OpenCL里面为了获取一个数组元素，都和这个结构差不多&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;num_entries&lt;/code&gt; 指名&lt;code&gt;platforms&lt;/code&gt;指针指向的空间有多大，防止越界&lt;/li&gt;
&lt;li&gt;&lt;code&gt;platforms&lt;/code&gt; 用来存放列表的指针,需要你在外部申请好空间&lt;/li&gt;
&lt;li&gt;&lt;code&gt;num_platforms&lt;/code&gt; 返回有多少个platforms&lt;/li&gt;
&lt;li&gt;错误码 OpenCL里的所有函数几乎都有错误返回值，具体错误返回值代表的意思可以到&lt;code&gt;CL/cl.h&lt;/code&gt;头文件查看。错误返回值一般是函数的返回值或者是最后一个参数。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;假设&lt;code&gt;num_entries&amp;lt;num_platforms&lt;/code&gt;，那么他只会吧前&lt;code&gt;num_entries&lt;/code&gt;个platform存起来，举例：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;//get platform numbers
err = clGetPlatformIDs(0, 0, &amp;amp;num);

//get all platforms
vector&amp;lt;cl_platform_id&amp;gt; platforms(num);
err = clGetPlatformIDs(num, &amp;amp;platforms[0], &amp;amp;num);&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;Device&lt;/strong&gt; 设备，也就是用来运算的实体&lt;/p&gt;
&lt;p&gt;获取所有设备的函数：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;cl_int clGetDeviceIDs (
    cl_platform_id  platform ,
    cl_device_type  device_type ,
    cl_uint  num_entries ,
    cl_device_id  *devices ,
    cl_uint  *num_devices )&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;platform&lt;/code&gt; 选择一个平台&lt;/li&gt;
&lt;li&gt;&lt;code&gt;device_type&lt;/code&gt; 你需要的设备类型，有如下几种&lt;/li&gt;
&lt;li&gt;&lt;code&gt;CL_DEVICE_TYPE_CPU&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;CL_DEVICE_TYPE_GPU&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;CL_DEVICE_TYPE_ACCELERATOR&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;CL_DEVICE_TYPE_CUSTOM&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;CL_DEVICE_TYPE_DEFAULT&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;CL_DEVICE_TYPE_ALL&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;后面这些参数用来获取列表&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;获取设备信息：&lt;code&gt;clGetDeviceInfo&lt;/code&gt; ，具体用法戳&lt;a href=&quot;http://www.khronos.org/registry/cl/sdk/1.0/docs/man/xhtml/clGetDeviceInfo.html&quot;&gt;这里&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;举例：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;//get device num
err=clGetDeviceIDs(platforms[DID],CL_DEVICE_TYPE_ALL,0,0,&amp;amp;num);
vector&amp;lt;cl_device_id&amp;gt; did(num);
//get all device
err=clGetDeviceIDs(platforms[DID],CL_DEVICE_TYPE_ALL,num,&amp;amp;did[0],&amp;amp;num);
cout&amp;lt;&amp;lt;&amp;quot;number of device: &amp;quot;&amp;lt;&amp;lt;num&amp;lt;&amp;lt;endl;
clGetDeviceInfo(did[0],
    CL_DEVICE_TYPE,
    infoSize,
    info,
    &amp;amp;infoSize);
cout&amp;lt;&amp;lt;*((cl_device_type*)info)&amp;lt;&amp;lt;endl;&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;context&lt;/strong&gt; 上下文，用来沟通设备平台和计算任务。&lt;/p&gt;
&lt;p&gt;创建上下文：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;cl_context clCreateContextFromType (
    cl_context_properties   *properties,
    cl_device_type  device_type,
    void  (*pfn_notify) (
      const char *errinfo,
      const void  *private_info,
      size_t  cb,
      void  *user_data),
    void  *user_data,
    cl_int  *errcode_ret)&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;properties&lt;/code&gt; 上下文的属性，用来指定平台 &amp;gt;openCL中的设置序列一般都是「property 种类」及「property 內容」成对出现，并以 0 做为结束。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;device_type&lt;/code&gt; 选择用平台中的那些设备来创建上下文&lt;/li&gt;
&lt;li&gt;&lt;code&gt;pfn_notify&lt;/code&gt; 错误回调函数&lt;/li&gt;
&lt;li&gt;&lt;code&gt;user_data&lt;/code&gt; 用来传给回调函数的参数&lt;/li&gt;
&lt;li&gt;错误码&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;举例：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;//set property with certain platform
cl_context_properties prop[] = { CL_CONTEXT_PLATFORM, reinterpret_cast&amp;lt;cl_context_properties&amp;gt;(platforms[DID]), 0 };
cl_context context = clCreateContextFromType(prop, CL_DEVICE_TYPE_ALL, NULL, NULL, &amp;amp;err);&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;commandQueue&lt;/strong&gt; 用来给device发送指令&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;cl_command_queue clCreateCommandQueue(
    cl_context context,
    cl_device_id device,
    cl_command_queue_properties properties,
    cl_int *errcode_ret)&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;context&lt;/code&gt; 指定上下文&lt;/li&gt;
&lt;li&gt;&lt;code&gt;device&lt;/code&gt; 指定设备&lt;/li&gt;
&lt;li&gt;&lt;code&gt;properties&lt;/code&gt; commandQueue设置，&lt;a href=&quot;http://www.khronos.org/registry/cl/sdk/1.0/docs/man/xhtml/clCreateCommandQueue.html&quot;&gt;详见&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;错误码&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;举例：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;cl_command_queue cqueue = clCreateCommandQueue(context, did[0], 0, &amp;amp;err);&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;program&lt;/strong&gt; 在上下文中加载代码，分两个步骤：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;加载&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;a href=&quot;http://www.khronos.org/registry/cl/sdk/1.0/docs/man/xhtml/clCreateProgramWithSource.html&quot;&gt;clCreateProgramWithSource&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;编译&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;a href=&quot;http://www.khronos.org/registry/cl/sdk/1.0/docs/man/xhtml/clBuildProgram.html&quot;&gt;clBuildProgram&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;参数设置什么的太多了，不一一详解了，举例:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;const char *src=getAllFile(&amp;quot;kernal1.cl&amp;quot;);
cl_program program = clCreateProgramWithSource(context, 1, &amp;amp;src, 0, 0);
err = clBuildProgram(program, 0, 0, 0, 0, 0);&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这里的&lt;code&gt;kernal1.cl&lt;/code&gt;使用特殊的语言写的，感觉几乎就是c语言，&lt;del&gt;只不过不能调用函数&lt;/del&gt;不过还是有一些限制的。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;//kernal1.cl
__kernel void adder(__global const float* a, __global const float* b, __global float* result)
{
  int idx = get_global_id(0);
  result[idx] = a[idx] +b[idx];
}&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;kernel&lt;/strong&gt; 相当于一次函数调用，从&lt;code&gt;program&lt;/code&gt;里找一个函数调用。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;cl_kernel adder = clCreateKernel(program, &amp;quot;adder&amp;quot;, &amp;amp;err);&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;Buffer&lt;/strong&gt; 相当于供函数调用的参数。&lt;/p&gt;
&lt;p&gt;创建buffer：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;cl_mem clCreateBuffer (
    cl_context context,
    cl_mem_flags flags,
    size_t size,
    void *host_ptr,
    cl_int *errcode_ret)&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;context&lt;/code&gt; 选择上下文&lt;/li&gt;
&lt;li&gt;&lt;code&gt;flags&lt;/code&gt; 用来决定这个buffer的属性，比如只读，只写，是否需要初始化等等，&lt;a href=&quot;http://www.khronos.org/registry/cl/sdk/1.0/docs/man/xhtml/clCreateBuffer.html&quot;&gt;详见&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;size&lt;/code&gt; &lt;code&gt;host_ptr&lt;/code&gt; 用于提供初始化的数组&lt;/li&gt;
&lt;li&gt;错误码&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;设置参数：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;cl_int clSetKernelArg (
    cl_kernel kernel,
    cl_uint arg_index,
    size_t arg_size,
    const void *arg_value)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;举例：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;cl_mem cl_a = clCreateBuffer(context, CL_MEM_READ_ONLY | CL_MEM_COPY_HOST_PTR, sizeof(cl_float) * DATA_SIZE, &amp;amp;a[0], NULL);
cl_mem cl_b = clCreateBuffer(context, CL_MEM_READ_ONLY | CL_MEM_COPY_HOST_PTR, sizeof(cl_float) * DATA_SIZE, &amp;amp;b[0], NULL);
cl_mem cl_res = clCreateBuffer(context, CL_MEM_WRITE_ONLY, sizeof(cl_float) * DATA_SIZE, NULL, NULL);
clSetKernelArg(adder, 0, sizeof(cl_mem), &amp;amp;cl_a);
clSetKernelArg(adder, 1, sizeof(cl_mem), &amp;amp;cl_b);
clSetKernelArg(adder, 2, sizeof(cl_mem), &amp;amp;cl_res);&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&quot;运行程序&quot;&gt;运行程序&lt;/h2&gt;
&lt;p&gt;运行程序分两步，创建运行指令和拷贝运行结果，貌似程序真正的执行是在拷贝运行结果的时候？&lt;/p&gt;
&lt;p&gt;创建运行指令:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;clEnqueueNDRangeKernel(
    cl_command_queue queue，
    cl_kernel kernel，
    cl_uint work_dims，
    const size_t *global_work_offset,
    const size_t *global_work_size, 
    const size_t *local_work_size,
    cl_uint num_events,
    const cl_event *wait_list,
    cl_event *event)&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;queue&lt;/code&gt; &lt;code&gt;kernel&lt;/code&gt; 指定队列和内核&lt;/li&gt;
&lt;li&gt;&lt;code&gt;work_dims&lt;/code&gt; 设定参数的维度，注意，这个参数是用来传递给不同进程的参数，同样也是接下来三个数组的大小，kernel里可以通过&lt;code&gt;get_work_dim&lt;/code&gt;来获得。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;global_work_offset&lt;/code&gt; 每一维初始下标&lt;/li&gt;
&lt;li&gt;&lt;code&gt;global_work_size&lt;/code&gt; 每一维结束下标+1&lt;/li&gt;
&lt;li&gt;&lt;code&gt;local_work_size&lt;/code&gt; 暂时不太清楚什么用，好像目的是吧不同进程捆绑起来便于沟通？&lt;/li&gt;
&lt;li&gt;&lt;code&gt;num_events&lt;/code&gt; &lt;code&gt;wait_list&lt;/code&gt; 用来设定在这个命令之前需要完成那些命令&lt;/li&gt;
&lt;li&gt;&lt;code&gt;event&lt;/code&gt; 返回当前事件&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;拷贝运行结果：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;cl_int clEnqueueReadBuffer (
    cl_command_queue command_queue,
    cl_mem buffer,
    cl_bool blocking_read,
    size_t offset,
    size_t cb,
    void *ptr,
    cl_uint num_events_in_wait_list,
    const cl_event *event_wait_list,
    cl_event *event)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;貌似有些和同步异步有关的东西，还不太明白，具体&lt;a href=&quot;http://www.khronos.org/registry/cl/sdk/1.0/docs/man/xhtml/clEnqueueReadBuffer.html&quot;&gt;戳这里&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;举例：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;size_t work_size=DATA_SIZE-1;
cout&amp;lt;&amp;lt;&amp;quot;begin run....&amp;quot;&amp;lt;&amp;lt;endl;
long long tt=clock();
err = clEnqueueNDRangeKernel(cqueue, adder, 1, 0, &amp;amp;work_size, 0, 0, 0, 0);
cout&amp;lt;&amp;lt;&amp;quot;err:&amp;quot;&amp;lt;&amp;lt;err&amp;lt;&amp;lt;&amp;#39; &amp;#39;&amp;lt;&amp;lt;work_size&amp;lt;&amp;lt;&amp;#39; &amp;#39;&amp;lt;&amp;lt;clock()-tt&amp;lt;&amp;lt;endl;

tt=clock();
vector&amp;lt;float&amp;gt; res(DATA_SIZE);
err = clEnqueueReadBuffer(cqueue, cl_res, CL_TRUE, 0, sizeof(float) * DATA_SIZE, &amp;amp;res[0], 0, 0, 0);&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这样一个简易的并行加法器就完成了， &lt;a href=&quot;https://github.com/cjld/opencl1&quot;&gt;完整代码&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;简单的利用这个加法器对我的CPU(i5-2410M)以及GPU(AMD HD 6470M)的性能做了一下测试：&lt;/p&gt;
&lt;p&gt;一共500个进程，每个进程做10000000次浮点加法，结果分别如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;AMD平台的GPU(AMD HD 6470M) device &lt;strong&gt;260ms&lt;/strong&gt; 相当于192GHz&lt;/li&gt;
&lt;li&gt;AMD平台的CPU(i5-2410M) device &lt;strong&gt;530ms&lt;/strong&gt; 相当于94GHz&lt;/li&gt;
&lt;li&gt;intel平台的CPU(i5-2410M) device &lt;strong&gt;136ms&lt;/strong&gt; 相当于367Ghz&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这不科学啊…我为了防止他偷偷帮我加优化，还特地改成了fibonacci数列求解，难不成你都智能到自动矩阵乘法优化了？还有显卡跑的还没cpu快你干嘛吃的…&lt;/p&gt;
&lt;p&gt;另外我已经彻底成为A卡黑了，在win8下驱动装了一年都没装好，而且回win7用opencl还会莫名其妙的蓝屏。&lt;/p&gt;
</description>
                <link>http://cjld.github.io/2013/07/10/dantengopencl</link>
                <guid>http://cjld.github.io/2013/07/10/dantengopencl</guid>
                <pubDate>2013-07-10T00:00:00+08:00</pubDate>
        </item>

        <item>
                <title>CSS3挺不错的</title>
                <description>&lt;p&gt;刚刚算是吧“零散”这个分栏目写完了，CSS3确实nb，像什么&lt;code&gt;nth-child&lt;/code&gt;这种选择器确实可以极大的降低编写网页难度。&lt;/p&gt;
&lt;p&gt;markdown在本地测试还是各种抽风，不知道是中文的问题还是系统是win的问题。&lt;/p&gt;
&lt;p&gt;哎，发现用jekyll写文章每次在给post取英文名的时候都很纠结，比如这篇&lt;code&gt;cssgood&lt;/code&gt;。&lt;/p&gt;
</description>
                <link>http://cjld.github.io/2013/07/07/cssgood</link>
                <guid>http://cjld.github.io/2013/07/07/cssgood</guid>
                <pubDate>2013-07-07T00:00:00+08:00</pubDate>
        </item>

        <item>
                <title>CG学习资料</title>
                <description>&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://gfx.cs.princeton.edu/pubs/Barnes_2009_PAR/index.php&quot;&gt;PatchMatch&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://kesen.realtimerendering.com/&quot;&gt;往年SIGGRAPH paper&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
                <link>http://cjld.github.io/2013/07/07/cgstart</link>
                <guid>http://cjld.github.io/2013/07/07/cgstart</guid>
                <pubDate>2013-07-07T00:00:00+08:00</pubDate>
        </item>

        <item>
                <title>博客建成</title>
                <description>&lt;p&gt;忙活了两天，总算吧blog建好了。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;粗体测试&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;斜体测试&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;xieti&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;以前的blog是在csdn上写的，&lt;a href=&quot;http://blog.csdn.net/jasonzhu8&quot;&gt;传送门&lt;/a&gt;。在这种地方写blog难免被各路大神鄙视缺少GEEK范&lt;em&gt;虽然我也从来不是个GEEK&lt;/em&gt;，不过出于可定制性的考虑，而且自己还有一点写网页的基础，正好自己不怎么懂后台和数据库，jekyll本质上又是动态生成静态页面，也就不需要操心数据库和后台了，攻击什么的也毫无压力，于是乎就选了在github上用jekyll搭建。&lt;/p&gt;
&lt;p&gt;顺便还学了下git、markdown和liquid，不错不错。&lt;/p&gt;
&lt;p&gt;搭建的过程中出了挺多蛋疼的问题，多亏lyp的帮忙：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;markdown的默认引擎在有中文无序列表的时候会抽风，得换个内核，也就是在&lt;code&gt;_config.yml&lt;/code&gt;里加一句&lt;code&gt;markdown: rdiscount&lt;/code&gt;，rdiscount默认没有安装，还得装一下。&lt;/li&gt;
&lt;li&gt;jekyll在解析的时候只支持UTF-8，vim在win下的默认编码不是UTF-8，这个问题跪了好久，最后在&lt;code&gt;_vimrc&lt;/code&gt;里加了这么一句&lt;code&gt;set fencs=utf8,gbk,gb2312,gb18030,cp936&lt;/code&gt;，暂时一切正常，（不能直接&lt;code&gt;set enc=utf8&lt;/code&gt;,要不然各种乱码）。&lt;/li&gt;
&lt;li&gt;还得在jekyll内核里面改改，才能支持好utf8，可以看这篇文章&lt;a href=&quot;http://log.medcl.net/item/2012/04/jekyll-encounter-encoding-problems/&quot;&gt;Jekyll遭遇编码问题&lt;/a&gt;。&lt;/li&gt;
&lt;li&gt;还是有时候莫名其妙的抽风，不生成&lt;code&gt;_site&lt;/code&gt;目录，把git回滚几个版本又正常了…&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;重新捏了下首页。&lt;/p&gt;
&lt;p&gt;改了下css，更加适应中文显示：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;li的&lt;code&gt;line-height&lt;/code&gt;改为24px&lt;/li&gt;
&lt;li&gt;默认中文标题字体为黑体，默认中文正文字体为宋体&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;终于明白jekyll的post前为什么要加日期了，因为方便页面字典序排序，同时也出现了一个问题就是，同一天发布的文章有可能后发布的反而在前面…囧&lt;/p&gt;
</description>
                <link>http://cjld.github.io/2013/07/06/blogstart</link>
                <guid>http://cjld.github.io/2013/07/06/blogstart</guid>
                <pubDate>2013-07-06T00:00:00+08:00</pubDate>
        </item>


</channel>
</rss>
